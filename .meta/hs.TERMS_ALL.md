# ENTIRETY of Haskell-related TERMS 

action
ad-hoc polymorphism
algebra of types
algebraic data type
arrow
bounded quantification
class instance
compile-time
constraint
continuation
dependent type
do notation
dynamic typing
fast and loose reasoning
first-class polymorphism
flexible instance
function overloading
function type
functions from terms to terms
functions from terms to types (dependent types)
functions from types to terms (parametric polymorphism)
functions from types to types (hkt)
GADT
generic function
generic programming
generics
higher-kinded type (HKT)
higher-order function (HOF)
higher-order type (HOT)
higher-order type operator
higher-rank type (HRT)
higher-rank polymorphism
Hindley-Milner type system
impredicative polymorphism
impredicativity
inductive data type
intersetion type
kind
let-polymorphism
levity polymorphism
linear haskell
linear type
liquid haskell
monomorphism
monotype
nullary type constructor
parametric function
parametric polymorphism
parametricity
polymorphic function
polymorphic recursion
polymorphic type
polymorphic value
polymorphism
polyvariance
predicate dispatching
predicativity
product types
quotient types
rank-2 type
rank-n type
recursion
recursive data type
refinement type
Reynolds's abstraction theorem
row polymorphism
runtime
scrap-your-boilerplate (SYB)
static dispatch
static polymorphism
static typing
subtyping polymorphism
sum types
system f
tail-call recursion
template haskell
theorems-for-free
type annotation
type application
type checking
type class
type constructor
type declaration
type erasure
type inference
type operator
type parameter
type safety
type signature
type system
type unification
type variable
type-level function
types-as-relations
types-as-sets
types-as-theorems
action
ad-hoc polymorphism
algebra of types
algebraic data type
arrow
bounded quantification
class instance
compile-time
constraint
continuation
dependent type
do notation
dynamic typing
fast and loose reasoning
first-class polymorphism
flexible instance
function overloading
function type
functions from terms to terms
functions from terms to types (dependent types)
functions from types to terms (parametric polymorphism)
functions from types to types (hkt)
GADT
generic function
generic programming
generics
higher-kinded type (HKT)
higher-order function (HOF)
higher-order type (HOT)
higher-order type operator
higher-rank type (HRT)
higher-rank polymorphism
Hindley-Milner type system
impredicative polymorphism
impredicativity
inductive data type
intersetion type
kind
let-polymorphism
levity polymorphism
linear haskell
linear type
liquid haskell
monomorphism
monotype
nullary type constructor
parametric function
parametric polymorphism
parametricity
polymorphic function
polymorphic recursion
polymorphic type
polymorphic value
polymorphism
polyvariance
predicate dispatching
predicativity
product types
quotient types
rank-2 type
rank-n type
recursion
recursive data type
refinement type
Reynolds's abstraction theorem
row polymorphism
runtime
scrap-your-boilerplate (SYB)
static dispatch
static polymorphism
static typing
subtyping polymorphism
sum types
system f
tail-call recursion
template haskell
theorems-for-free
type annotation
type application
type checking
type class
type constructor
type declaration
type erasure
type inference
type operator
type parameter
type safety
type signature
type system
type unification
type variable
type-level function
types-as-relations
types-as-sets
types-as-theorems
type declaration
data declaration
type class
type function
abstract data type, ADT
invariant
type invariant
static invariant
static restriction
type system Hindley-Milner
type system: assurance weakening (variants, dynamics)
type system: ssurance strengthening (phantom types)
phantom type
dynamics
generics
expression problem
tagless-final
higher-order abstract syntax, HOAS
data types a la carte
initial encoding
variance
contravariance
covariance
noncovariance
polymorphic data type
Ad-Hoc Polymorphism
type-level programming
type-level function
heterogeneous list
existential type
recursive data type
recursion patterns
catamorphism
anamorphism
hylomorphism
abstract algebra
abstract data type, ADT
abstract syntax tree, AST
ACID state
Ad-Hoc Polymorphism
AES encryption
algebraic data type, ADT
Alternative
ambiguous type
ambiguous type variable
antiquotation
Applicative type class
ApplicativeDo
Applicatives
arbitrary-rank polymorphism
Arbitrary-rank polymorphism with RankNTypes
arithmetic
arithmetic operators
arithmetic sequence
Arrow kind
Arrow
ascription
associated Term
associated Type Family
Async
attoparsec library
BangPatterns
Base
Bifunctors
binary search tree, BST
binary tree
binding
Blaze
block argument
Bool
Boolean Blindness
Boot Libraries
Bottoms
Bounded type class
BTree
ByteString
Cabal
Cabal New-Build
cabal-install
canonical constructor
Canonical Representations
Cardinality
case expression
Categories
Categories
Chans
Char
Class declaration
Classes
Closed Type Families
Cmm
Coercions
cofree
cofree comonad
Combinatorics
comment
Comments
Common functors as the base of cofree comonads
Common GHC Language Extensions
Common monads as free monads
comonad
Compiler Design
compiler pragma
Compiler Theory
Compilers
Complex Numbers
composition
comprehensions
concatenation
Concepts
Concurrency
conditional
conditional expressions
Conditionals
Conduits
Configurator
constraint
Constraint kind
Constraint Kind
Constraint Kinds
Constructive Reals
constructor
Cont
Containers - Data.Map
context-free syntax
Continuation
Continuation Monad
continuations
Continuous Integration
Contravariant Functor
Control.Exception
Core
core language
CPP
Creating Custom Data Types
Criterion
Cryptography
CSV
curly braces
curried application
curried function
curried functions
Currying
Curve25519 Diffie-Hellman
Custom Errors
Custom Lexer
Custom Preludes
Custom Type Error
Data
data constructors
data ctors
Data declarations
Data Formats
Data Kind
Data Kinds
Data Structures
Data.Aeson - JSON in Haskell
data.aeson library (json in haskell)
data.map container
Data.Text
data.text module
Databases
Databases
datatype promotion
Datatypes
Datatypes
Date and Time
Dates and Times
Debugger
Decimal & Scientific Types
declaration
declarations
Deepseq
Deferred Type Errors
Defunctionalization
Defunctionalization
Dependent Pairs
Dependent Type
derivable classes
DeriveAnyClass
derived instance
Derived primitives
DeriveFoldable
DeriveFunctor
DeriveGeneric
DeriveTraversable
deriving
Deriving Structural Polymorphism
DerivingStrategies
DerivingVia
desugaring
Dictionaries
Differential Equations
DList
do expression
do expressions
Do I need to Learn Category Theory?
Do Notation
do-expression
Docker Images
Duality
DuplicateRecordFields
Dynamic Type
Dynamic Types
DynFlags
eagerness
Ed25519 EdDSA
Editor Integration
Effect Systems
Efficiency
Eightfold Path to Monad Satori
Either Monad
EKG
Elliptic Curves
EmptyCase
Endofunctor
Enum type class
enumeration
Eq type class
equation
Error Handling
errors
Escaping Text
evaluation
exception handling in the I/O monad
Exceptions
ExceptT
exhaustive pattern matching
Exhaustiveness
Existential Quantification
Existential Type
Existential Type Eliminator
Exponential Type
export list
exported definitions
exporting
expression
expression type-signature
ExtendedDefaultRules
Extensible Data
Extension Dependencies
external c interface
external entity
F-Algebras
FFI
Final Interpreters
Finally Tagless
First Class Family
first-match policy
Fixity declarations
fixity resolution
Flags
FlexibleContexts
FlexibleInstances
Floating type class
Foldable / Traversable
foldable type class
Foldables
foreign declarations
foreign function interface (FFI)
Frameworks
Free Monads
Free Monads
Free Theorems
function application
Function Composition
function definition
Function Monad
Function Pointers
function scope
function types
functional dependency
Functions
Functor
Fused Effects
GADT
Galois Fields
Generalized Constraint Kinded Existential
generator
Generic
Generic Deriving
Generic Metadata
Generic Representation
Generics
GHC
GHC API
ghc language extensions
ghc-heap-view
GHCi
ghci.conf
ghcid
ghcup
Glasgow Haskell Compiler (GHC)
gloss
GMP Integers
GPU Kernels
Graph Theory
Graphics with Gloss
Graphs
guard
guarded equations
Guards
Guards
Hackage
Hackage
haddock
Haddock
happy
Happy & Alex
hash kind
Hashtables
Haskeline
haskell features
haskell kernel (core language)
Haskell platform
haskell scripts
Haskell Type Classes
Haskell Types
Hastache
Heterogeneous List
HIE Bios
Higher Kinded Types
higher-order
Higher-order function
higher-rank type
Hint and Mueval
historical background
Historical Extensions
hkt
HLint
HLists
HOAS
hof
Hoogle
How to Read
Hpack
hsc2hs
hscolor
HTTP Requests
I/O
identifier
import declaration
importing
importing and exporting instance declaration
Impredicative Types
IncoherentInstances
indentation
Indexed Monads
Indexed Monads
Induction on lists
Induction on numbers
inference
Infinite structures
infinite types
infix operator
Infix operators
Injectivity
Inline CMM
Inliner
inlining
instance declaration
Instance Search
instantiation
Integral type class
Interactive programming
Interface Files
Interpreters
IO Monad
IO/ST
IORef
irrefutable pattern
Irrefutable Patterns
ISO8601
Isomorphism
Isomorphisms
JSON
Kan Extensions
keywords
kind
Kind
Kind Indexed Type Families
kind inference
kind polymorphism
Kind Polymorphism
kind signatures
Kind Signatures
kind system
Kind System
kind-directed compilation
kind-polymorphic
Kleisli Category
labeled data ctor helpers
labels
lambda abstraction
lambda application
Lambda Calculus
lambda expressions
LambdaCase
lambdas
language constructs
language extension
Language extensions
Language Extensions
language-c-quote
layout
layout vs braces and semicolons
laziness
Laziness
Lazy evaluation
Lazy IO
lazyness
let expression
let expressions
let scope
lexical syntax
lexigographic order
Lifted Base
lifted type
Linear Allocation
linearity
Linux Packages
Liquid Haskell
list comprehension
List Comprehensions
List Monad
list processing functions
list types
Lists
literal
literate comments
LLVM
Local Packages
Logging
Lucid
main function
Main module
Manual Proofs
Proof
eap
marshalling
Aathematics
aaybe
taybe Monad
Megaparsec
aetaprogramming
Minimal Annotations
Modern Haskell
Modular programming
module alias
module hierarchy
aodule import
aodule name aliasing
module name qualification
module ktructure
Module
monad
aonad Laws
aonad Methods
Monad Morphisms
Monad Par
monad transformer
Monad Transformers
Monad type class
MonadFail
MonadFix
Monadic parsing
MonadPlus
MonadPlus
Monads
Monoid type class
Monoidal Categories
Monoidal Functor
Monoids
most general type
mtl
mtl / transformers
Multiline Strings
MultiParam Typeclasses
multiple arguments
multiple recursion
MultiWayIf
Mutable Vectors
mutual recursion
MVars
name clashes and closure
Name Conventions
NamedFieldPuns
Names
Natural Numbers
Natural Transformations
nested declarations
nested tuples
Network & Web Programming
Newtype declarations
Newtype Deriving
Newtypes
NoMonomorphismRestriction
Non-Injectivity
non-strict evaluation
NonEmpty
Num type class
Number Theory
NumDecimals
Numeric expressions
numeric literal
Numeric Tower
offside rule
Open Product
Open Sum
operator
operator application
operator sections
operators
Operators and Sections
Optimisation
Optimization
Optparse Applicative
Ord type class
Ormolu
Orphan Instances
Outputable
overlapping
OverlappingInstances
Overloaded Label
Overloaded Lists
overloaded types
OverloadedLabels
OverloadedStrings
overloading
Package Databases
Package Managers
PackageImports
Pairing Cryptography
pairs
parametric constructor
parametric polymorphism
parametrically polymorphic functions
parenthesized expression
Parsec
parsec library
Parser
Parsing
Parsing HTML with taggy-lens and lens
partial function
Partial Functions
PartialTypeSignatures
Password Hashing
Path Files
pattern
Pattern Matching
PatternGuards
PatternSynonyms
Performance testing
phantom type
Philosophy
PHOAS
pipe
Pipes
Pipes
polymorphic type
polymorphic types
polymorphism
Polynomial Arithmetic
Polysemy
Polyvariadic Functions
Postfix Operators
Postgres
Pragmas
Pragmas
precedence
predefined types and classes
predicate
Prelude
Prelude
prelude exports
prelude preludeio
prelude preludelist
prelude preludetext
Preludes
Pretty Printers
pretty-simple
prettyprinter
Primops
Printf
Printf Tracing
Product Type
Profiling
program structure
Project Structure
Promoted Syntax
Promotion
Promotion of Built-In Types
Protolude
Proxies
Proxies
proxy
pure functions
Pure Functions
qualified import
Quantification
Quasiquotation
quasiquotes
QuickCheck
QuickSpec
Rank
Rank-N Type
rank-n types
Rank-N Types
Read type class
Reader
Reader / ReaderT
Reader Monad
ReaderT
ReaderT
records
Records
records, datatypes with field label
RecordWildCards
recursion on lists
Recursion Schemes & The Morphism Zoo
Recursive function
recursive type
Recursive types
RecursiveDo
Redis
reduction
reductions
Regex
Regular Languages
Replacing Partiality
Repline
Req
Rewrite Rules
Rewrite rules (GHC)
rewrite rules in ghc
rigid type variable
rigid type variables
Role
Role
Roles
RTS Profiling
Runtime System
RWS Monad
Safe Haskell
SAT Solvers
Scoped Type Variables
Scoping Information with Existential
Scotty
script file
section, sectioning
sectioning
Secure Memory Handling
Selda
Semaphores
Semigroup type class
separate compilation
Seq and WHNF
seq forces evaluation
Sequence
Sequencing
sequencing I/O operations
Servant
Set
Set theory
SHA Hashing
short-circuited
Show type class
side effects
Side Effects
Silently
SIMD Intrinsics
Simple Parsing
Singleton Types
Singletons Package
Size-Indexed Vectors
SmallCheck
SMT Solvers
Sorting Algorithms
source files
Sparks
specialization
Specialization
Spoon
Sqlite
ST Monad
Stack
Stack Traces
Stackage
Stackage
standard haskell classes
standard haskell types
Standard Hierarchy
standard I/O functions
star kind
State Monad
Static Compilation
static semantics of function and pattern bindings
Statistics & Probability
STG
STM
Stochastic Calculus
Storable Arrays
Strategies
Streaming
Strict
strict application
strict evaluation
StrictData
Strictness
String
String
String comprehensions
String Conversions
string literal
String Splitting
Strings
Structured Logging
Sum Type
Symbols
Syntax in Functions
Tasty
tasty testing
template haskell
Template Haskell
Template Haskell
Template Haskell & QuasiQuotes
Templated Type Classes
Templated Type Families
Term
Testing
Testing with Tasty
Text
Text.Builder
The Advanced
The Benign
The Curry-Howard Isomorphism
The Dangerous
The Debate
The Lowlevel
Theoretical Foundations
Theory of Computation
Theory of Programming Languages
Threads
Threadscope
thunk
Thunks
time
top-level scope
Transformers
Traversables
Tree
tuple types
tuples
Tuples
Tuples (Pairs, Triples, ...)
TupleSections
TVar
Type
Type Applications
Type Class Extensions
Type Classes
type classes and overloading
Type Constraint
type constructors
type ctors
Type declarations
Type Equality
Type Error
Type Families
Type Families
Type Families
type family
Type Holes
Type Inference
type instance
Type Kind
type role
Type Schema
Type Scoping
type signatures
Type Signatures
Type systems
Type Systems
Type Theory
Type-Level Computation
Type-Level Defunctionalization
Type-Level Functions
type-signature
Typeable
TypeApplications
Typeclasses
typed hole
Typed holes
TypeFamilyDependencies
Typelevel Dictionaries
Typelevel Numbers
Typelevel Operations
Typelevel Strings
Types
TypeSynonymInstances
Unbound
Unbound Generics
unboxed type
Unboxed Types
Uniplate
unit
unit expression
Universal Quantification
unlifted data type
unlifted type
Unordered Containers
Unsafe Functions
user data type
user-defined datatypes
Using GHCi
value
variable
variables
Variance
vector
Vector
Vectors
Version Bounds
ViewPatterns
Void
Warp
Web Development
well-founded recursion
well-typed
What is Haskell?
What Should be in Prelude
Where & Let Clauses
where expression
Why are monads confusing?
Worker/Wrapper
Writer Monad
Yaml
Z-Encoding
ZeroMQ
zkSNARKs


abstract data-types
marshalling
abstract loggers
abstract-par library
backend foreign function interface
conditional execution
flow control
folding
kernels
permutation
reducing
rudimentary array computations
scalars
segmenting
stencils
tuples
accelerate-cuda package
generated code
inspecting generated code
accumulator parameter
accumulators
acid-state package
ad hoc polymorphic
aeson library
affinity
inlining
aggressive inlining
allocations
minimizing
profiling
Haskell project anatomy
array reductions
via folding
arrays
extending arrays
mapping arrays
Async API examples, timeouts
asynchronous errors, handling
asynchronous processing
Async API
composing with Concurrently type
attoparsec
AWS

base
module Data.Fixed
basic-prelude library
benchmarking
criterion
benchmarks
establishing bidirectional channels
handling binary and textual data
bit arrays
representing bit arrays
blobs of bytes
handling blobs of bytes
builder abstractions, used for iterative construction
handling bytes
working with characters
working with strings
binary I/O
binary library
binary serialization, libraries
binary
cereal
store
binary serialization of Haskell values
biographical profiling
blaze-html
bounded thread
boxed types
branching
buffering modes
BlockBuffering
LineBuffering
NoBuffering
builder abstractions
  using, for iterative construction 34, 35
  using, for strings 35

common types
cabal file
fields
flags
cassava library
cereal library

C functions
  calling, from Haskell 271, 272
Chan
  used, for broadcasting 206, 207
  channels
  using 306, 308
characters
text library, using 33
charts
creating 370
charts, libraries
Chart 370
Chart-cairo 370
Chart-diagrams 370
chunked-data library 364
classy-prelude library 361
closures 304
Cloud Haskell 302
cmdargs library 371
Cmm 248
code optimizations
common subexpressions, eliminating 229
float-in 228
float-out 228
liberate case duplicates code 230
state hack 227
Common Subexpression Elimination
(CSE) 229
common types, C 272, 273
common types, Haskell 272, 273
compiler code optimizations 17
concurrency primitives 200
conduit library 361
console-program 371
Constant Applicative Form (CAF) 67
containers library 344
control and utility libraries
basic-prelude 361
chunked-data 361
classy-prelude 361
conduit 361
convertible 361
io-streams 361
lens 361
pipes 361
Control.Concurrent (base) library 368
control inlining
about 114, 115
definitions, specializing 116
phase control 117
rewrite rules, using 115, 116
convolution operation
with stencils 149-151
cost centre-based heap profiling 73-76
cost centres
about 64
setting, automatically 68-70
setting, manually 64-67No Comments.[ 377 ]
C preprocessor (CPP)
about 232
use cases 232
criterion benchmark suite 84
cryptography 356
cryptography, libraries
cryptonite 356
HsOpenSSL 356
RSA 356
SHA 356
skein 356
cryptonite package 356
CSV input 349
CSV output 349
CUDA backend
using 294
CUDA platform 285
CUDA programs
debugging 295
custom Prelude
using 363, 364
data marshal 280
data parallel programming 141, 142
data representation
libraries 343
datatype fields
unpacking 23
data-type generic programming
about 256
generic sum example 256-258
debugging
options 241
Decimal (module Data.Decimal) library 345
definitions
specializing 116
delayed arrays 143
delayed representations 146
diagrams
creating 370
Diagrams library 370
difference lists
performance 38
using 37
using, with writer monad 38, 39
discrete-time events 327-329
domain specific language (DSL) 264
ekg
used, for monitoring over HTTP 89-91
Elerea
about 318, 319, 368
limitations 324
performance 324
encoding 166, 346
encoding, libraries
aeson 348
cassava 348
json-autotype 348
xml 348
yaml 348
ephemeral data structures
about 49
mutable arrays, using 50, 51
mutable references 50
mutable vectors, using 51, 52
errors
asynchronous errors, handling 106
synchronous errors, handling 102, 103
esqueleto DSL 352
esqueleto library 350-352
Eval monad 132
eventlog
used, for tracing 241
events, and behaviors
combining 335
switching 336
examples, from image processing
about 154
image, loading from file 155
letters, identifying with
convolution 155, 157
performance, evaluating 159-161
performance, testing 159-161
strings, extracting from image 157
exception hierarchy 104, 105
exceptions
handling 101, 366, 367
exceptions, libraries
safe-exceptions 366No Comments.[ 378 ]
failure, handling
about 310
matching on message queue 311, 312
message-passing performance 312
monitors, firing up 311
processes, linking together 312
file handles 165
finger trees 40
FlexibleInstances 121
force
using 131
foreign function interface (FFI) 271
formats
encoding from 348
encoding to 348
FP Complete 99
Frames library 369
functional dependencies 118, 119
Functional Graph Library (fgl) 344
functional graphs 344, 345
Functional Reactive Programming,
libraries
Elerea 368
Reactive-banana 368
Yampa 368
function pointers 278
fusion 146
futures 138
GADTs
performance 26, 27
garbage collector
parallel GC 239
tuning 239
general algebraic datatypes 24
General-Purpose Computing On Graphics
Processing Units (GPGPU) 285
getopt parsers 371
GHC
code optimizations, adjusting 227
code transformations, adjusting 227
compiling, via LLVM route 230
Haskell source code, pre-processing 232
operating 224
operating, circular dependency
problem 226
shared libraries, building 231
shared libraries, linking 231
type-safety, enforcing with Safe
Haskell 233
using, like pro 224
GHC Core
considerations 249
GHC extensions
about 121
for guards 123
for patterns 123
GHCi
Repa, working 142, 143
tip 15
GHC options
flags 242
LLVM backend 242
optimization, turning off 242
optimization, turning on 242
Runtime System (compile-time),
configuring 242, 243
Safe Haskell compilation, controlling 243
summaries 241
GHC PrimOps
coding in 112
GHC Runtime System
and threads 211, 212
asynchronous exceptions, masking 212
GHC's internal representations
GHC Core, reading 248, 249, 250
interpreting 248
Spineless tagless G-machine (STG) 251, 252
GHC-specific features
about 253
kinds encode type, representation 254
Glasgow Haskell Compiler. See GHC
GNU Multiple Precision Arithmetic Library
(GMP) 28
granularity
fine-tuning, with buffering 136
fine-tuning, with chunking 136
Graphics Processing Units (GPUs) 285
green threads 235
guarded recursion 10, 11No Comments.[ 379 ]
Hackage 294
Happstack 356
happy library 357
hashtables library 344
Haskell
about 164
code lifting to Q, with quotation
brackets 264
common types 272, 273
constN function 263
data, reifying into template objects 264
evaluation stack, using 238
generating 259
missiles, launching on compilation 264
names, in templates 261, 262
quasi-quoting, for DSLs 267, 268
setters, deriving with Template
Haskell 265-267
smart template constructor 262
splicing, with $(â€¦) 260
tests, writing for 107
Haskell callbacks, from C 279, 280
Haskell functions
exporting 275, 276
Haskell programs
space usage, inspecting 12-15
time, inspecting 12-15
Haskell project
anatomy 94-96
HaskellR project 370
HaTeX 369
HDBC 350, 352
HDBC-odbc 350
heap objects, biographical profiling
state DRAG 83
state LAG 83
state USE 83
state VOID 83
heap profiling
about 71, 73
cost centre-based heap profiling 73-76
here library 359
H (HaskellR) 369
hmatrix-gsl-stats library 369
hmatrix library 369
hpc command-line utility 110
HsOpenSSL library 356
Hspec
about 107, 109
reference 109
hstatistics library 369
http-client library 353
HTTP clients and servers, libraries
http-client 353
http-client-tls 353
wai 354
warp 354
wreq 353
HUnit
used, for unit testing 108
ihaskell 369
indefinite blocking 236
indices 146-149
inlining
about 17
considerations 17
International Components for Unicode
(ICU) 34
Inter-process Communication (IPC) 170
I/O
about 163
binary I/O 166, 167
lazy I/O 164, 165
lifting, base with exception
handling 220, 221
lifting, from base monad 219, 220
lifting up from 218
textual I/O 168
top-level mutable references 218, 219
I/O performance
with filesystem objects 168
io-streams
example 181-183No Comments.[ 380 ]
json-autotype library 348
JSON-RPC APIs 355
lazy evaluation schema
about 1, 2
folds 6
sum, writing correctly 3, 4
weak head normal form 5
lazy I/O 164, 165
lenses
using 361, 363
lens library 361
libraries
installing, with profiling 70
libraries, for data representation
bytestring 344
containers 344
hashtables 344
mutable-containers 344
text 344
unordered-containers 344
vector 343
libraries, for mathematics
hmatrix 369
hmatrix-gsl-stats 369
matrix 369
libraries, for monads and transformers
lifted-base 365
LogicT 365
monad-control 365
monad-logger 365
monad-loops 365
monad-unlift 365
stm-lifted 365
libraries, for parallel and concurrent
programming
abstract-par 368
Control.Concurrent (base) 368
monad-par 368
monad-par-extras 368
parallel 368
repa 368
libraries, for parsing and pretty-printing
attoparsec 357
happy / alex 357
megaparsec 357
parsec 357
pcre-heavy 357
libraries, for pretty-printing and text
formatting
here 359
interpolate 359
text-format 359
wl-pprint-* packages 359
libraries, for Scripting and CLI applications
cmdargs 371
console-program 371
haskeline 371
propellor 371
shake 371
shelly 371
turtle 371
libraries, for statistics
hstatistics 369
statistics 369
libraries, for testing and benchmarking
criterion 372
doctest 372
HSpec 372
HUnit 372
QuickCheck 372
tasty 372
weigh 372
libraries, Repa
repa-algorithms 154
repa-devil 154
repa-flow 154
repa-io 154
repa-stream 154
lifted-base library 365
logging, in Haskell
about 191
with FastLogger 191
LogicT library 365
MagicHash language extension 112
manifest representations 145No Comments.[ 381 ]
marshalling
in standard libraries 283
matrix library 369
megaparsec library 357
memoization 7
memory
allocating, outside heap 281
mersenne-random library 367
Mersenne Twister 367
message-passing 302
message type
creating 302, 303
migrator 352
modules
Safe 233
Safe-Inferred 233
Trustworthy 233
UnSafe 233
moments
about 331
observing, on demand 336
monad-control library 365
monadic loggers
customizing 196, 197
monadic logging 195
monad instance 331
monad-logger library 365
monad-loops library 365
monad-par library 368
monad-unlift library 365
monad-par-extras library 368
MonadRandom library 367
monads
catch function, implementing 106, 107
free monads 57-59
list monad 55-57
monad transformers, working with 59
speedup, via continuation-passing
style 59, 60
throw function, implementing 106, 107
transformer 55-57
working with 365
monad stacks
working with 55
monad transformer library (mtl) 59
monad-unlift library
need for 366
monitoring
in realtime 88
monitoring, over HTTP
with ekg 89-91
monomorphism restriction (MR) 122
multi-package projects 101
MultiParamTypeClasses 121
mutable-containers library 344
mutable vectors
bubble sort, using with 53, 54
using 52, 53
mutually recursive signals
about 320
side effects, signalling 321, 322
signal networks, changing
dynamically 322, 323
MVars
about 199, 203
features 204
used, as building blocks 205
mwc-random library 367
networking
about 169, 313, 314
above transport layer 173
networking and HTTP, libraries
connection 353
network (module Network) 353
network-uri 353
nodes 313, 314
NoMonomorphismRestriction language
extension 122
non-deterministic parallelism
with ParIO 139, 140
Normal Form Data (NFData) 87
Normal Form (NF) 5, 131
numbers (modules Data.Number.*)
library 346
numerical data
handling 28, 29
numeric data, libraries
base (module Data.Fixed) 345
Decimal (module Data.Decimal) 345
numbers (modules Data.Number.*) 346
numeric types, Haskell 28No Comments.[ 382 ]
objects
outside heap 76-80
pointing, in heap 281
O(log n) 48
OpenCL 285
Operating System (OS) thread 201
parallelism
diagnosing 140, 141
Parallel library 368
ParIO
using, for non-deterministic
parallelism 139, 140
Par monad 136-138
parsec library 357
parsing 357
partial functions 19
partitioned arrays 151
patricia 345
PatternGuards 123
PatternSynonyms 123
pcre-heavy library 357
Perl 5 compatible regular expressions 359
persistent library 350, 351
persistent-odbc 350
phantom types 118
pipes
benefits 187
drawbacks 187
pipes library 361
polymorphic 2
polymorphic programs 18
polymorphism performance 18
pretty-printing 359
primitive parallelism 128, 129
primops 247
processes
about 302
creating 303
profiler
unexpected crashes, debugging with 70, 71
profiling
about 63
in realtime 88
libraries, installing with 70
options 241
promises 138
propellor library 371
property checks 107, 108
pseq 131
QuickCheck 107
random-fu library 367
random number generators 367
random number generators, libraries
mersenne-random 367
MonadRandom 367
mwc-random 367
random-fu 367
raw UDP traffic 172
Reactive-banana
about 331
first GUI application 332
graphical display, with
wxWidgets 332-334
input, adding 338
input, adding dynamically 340
input, adding via handlers 338, 339
input, adding via polling 338, 339
output, adding 338
output, adding dynamically 340
Reader 55
Reader Writer State (RWS) 59
recursion 9, 337
regular expressions, in Haskell 358
remote process
calling 309
Repa
about 141
working with 142, 143
repa-algorithms library 154
Repa code
writing 153
repa-devil library 154
repa-flow library 154
repa-io library 154
repa library 368No Comments.[ 383 ]
repa-stream library 154
resources
handling 164
managing, with ResourceT 173, 174
reading 164
writing 164
ResourceT
resources, managing with 173, 174
REST API
programming 355
Rest framework, Silk
reference 355
retainer profiling 80-83
reverse polish notation (RPN) 10
rewrite rules
using 115, 116
RSA library 356
RSpec 109
RTS options
debugging 244
garbage collection 244
memory management 243
profiling 244
runtime system statistics 244
scheduler flags 243
summaries 243
runtime system, GHC
garbage collector, tuning 238
green threads 235
heap management 237, 238
memory management 237, 238
profiling options 240, 241
scheduler threads 235
stack management 237, 238
tracing options 240, 241
tuning 234
safecopy package 350
Safe Haskell 223
schedules 136-138
ScopedTypeVariables 124
semantics 337
Seq 40
sequential data, handling
about 36, 37
difference lists, using 37
zippers, using 39
serialization 346
Set Cost Centre (SCC) 65, 71
SHA library 356
shared library
compiling 276, 277
sharing
increasing 15, 16
shelly library 371
signal functions
state, adding to 325, 326
SimpleLocalNet backend
running with 305, 306
Single Instruction, Multiple Data
(SIMD) 231, 253
slicing 147
SmallCheck 107
Snap 356
sockets 169
Software Transactional Memory (STM)
about 199, 208
alternative transactions 210
bank account example 208, 210
exceptions 210
spark pool
about 235
dud 130
fizzled 130
GC'd 130
overflowed 130
sparks 130
sparse data, handling
about 47
containers package, using 47
unordered-containers package, using 48
spawn function
for futures 138, 139
for promises 138, 139
spawning 304
spec testing 107
Spineless Tagless G-machine (STG) 224
stable pointers 280
stack manual
reference 100No Comments.[ 384 ]
stack tool
using 99, 100
state
adding, to signal functions 325, 326
static addresses
importing 273-275
static functions
importing 273-275
statistics library 369
stm-lifted library 365
store library 347
strategies
about 132
composing 134, 135
working 133
stream fusion 33
streaming 175
streaming library
selecting 175
streaming, with conduits
about 188, 189
conduits, resuming 190, 191
exceptions, handling 189
resources, handling 189
streaming, with io-streams
about 176, 177
combinators, using 179
exceptions, handling 179-181
input streams, creating 177-179
output streams, using 179
resources, handling 179-181
streaming, with pipes
about 184
category theory 186
exceptions, handling 187
for-loops 186
pipes, composing 185
pipes, executing 185
stream monad 56
StrictData 124
strictness
annotating 23
strings
text library, using 33
subtle evaluation
with pseq 131
sum-type encoding 349
supplementary HTTP libraries
json-rpc 354
REST 354
wai-websockets 354
websockets 354
switching 327-329
synchronous errors
handling 102, 103
szipWith 152
tabular data, handling
about 42
vector package, using 43-46
Tagsoup 359
Tasty
about 109
reference 109
TCP/IP client
acting as 169
TCP server
acting as 170, 171
Template Haskell
about 247
used, for deriving setters 265-267
test frameworks
about 109, 110
Hspec 109
RSpec 109
tests
writing, for Haskell 107
test suites 98
text-format library 359
text formatting 360
text library 344
textual I/O 168
threads
about 200
and mutable references 200
atomic operations, performing with
IORefs 202
thunk accumulation, avoiding 202
ThreadScope 231, 241
Thread State Objects (TSOs) 235No Comments.[ 385 ]
time
profiling 63
working with 326
timed log messages 193-195
tools, for research and sketching
HaTeX 369
H (HaskellR) 369
ihaskell 369
tracing
eventlog, using 241
transformers
working with 365
Trivia, at term-level
about 110-112
coding, in GHC PrimOps 112-114
control inlining 114, 115
Trivia, at type-level
about 117
associated types 120, 121
functional dependencies 118, 119
phantom types 118
type families 120, 121
turtle library 371
type families 121
types
converting between 363
UnboxedTuples extension 112
unboxing
about 23
anonymous tuples, using 25
unexpected crashes
debugging, with profiler 70, 71
Unicode-correct 33
unit testing
with HUnit 108
unordered-containers library 344
UNPACK
used, for unboxing 23-25
vector library 343
ViewPatterns 123
wai library 354
wai-websockets library 354
warp HTTP server 355
warp library 354
Weak Head Normal Form 87
weak references 236
Weak ThreadId 237
Web Application Interface 354
WebSocket applications 355
WebSockets
using 355
web technologies 356
web technologies, libraries
amazonka/ AWS 357
blaze-html 356
Snap / Happstack 356
Yesod framework 356
windowing function 44
wl-pprint package 359
worker/wrapper transformation 9
wrappers 278
wreq library 353
Writer 55
XML
parsing 359
xml library 
yaml library 348
Yampa
about 324, 368
events 325
integrating, to real world 330, 331
signal functions 324
Yesod framework 356
Yesod web framework 350
zippers
both ends, accessing with Seq 40-42
