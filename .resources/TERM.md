# Haskell: Terms



* kind system
kind
data constructors
type constructors
type signatures
kind signatures
hof
hkt
unboxed type
unlifted type
constraint
datatype promotion
kind polymorphism
levity polymorphism
star kind
Type kind
TYPE kind
Constraint kind
hash kind
kind-directed compilation



---


* Basics:
introduction
haskell features
historical background
glasgow haskell compiler
prelude
haskell scripts

* Functions:
functional programming
equation
equational reasoning
pure functions
function definition
function application
function types
curried functions
lambda expressions
operator sections
sectioning
Recursive function
recursion on lists
multiple arguments
multiple recursion
mutual recursion
Higher-order function
list processing functions
function composition

* Types and classes
types
Bool
Char
String
numbers
tuples
Maybe
lists
functions
Type declarations
Data declarations
Newtype declarations
list types
tuple types
polymorphic types
type class
overloaded types
Recursive types
Class declaration
instance declaration

* Classes:
Functors
Applicatives
Monads
Monadic parsing
Foldable
Monoids
Foldables
Traversables
IO
Alternatives
MonadPlus

* Misc:
Arithmetic operators
Numeric expressions
Performance testing
pattern matching
conditional expressions
guarded equations
Guards
List comprehensions
String comprehensions
Lazy evaluation
Evaluation strategies
reductions
Infinite structures
Modular programming
strict application
Equational reasoning
Induction on numbers
Induction on lists
continuations
Defunctionalization
Interactive programming
Sequencing
Derived primitives



* classes:
type class
derivable classes

* modules:
module
module import
module name qualification
module name aliasing



do-expression
program structure
haskell kernel (core language)
labeled data ctor helpers
expression
value
type
identifier
variable
constructor
namespace
comment
literal
numeric literal
character literal
string literal
layout vs braces and semicolons
offside rule
errors

lambda abstraction
lambda application
curried application
operator application
operator
section, sectioning
conditional

list
tuple
unit

unit expression
parenthesized expression
arithmetic sequence
list comprehension
let expression
case expression
do expression
records, datatypes with field label
type-signature
expression type-signature
pattern matching

declaration
binding
type class

user-defined datatypes
type classes and overloading
nested declarations
static semantics of function and pattern bindings
kind inference

module
module structure
export list
import declaration
importing and exporting instance declaration
name clashes and closure
standard prelude
separate compilation
abstract datatype

predefined types and classes
standard haskell types
strict evaluation
standard haskell classes
numbers

basic I/O
standard I/O functions
sequencing I/O operations
exception handling in the I/O monad

context
foreign function interface (FFI)
foreign declarations
external entity
external c interface
marshalling

standard prelude
prelude preludelist
prelude preludetext
prelude preludeio

lexical syntax
layout
literate comments
context-free syntax
fixity resolution
fixity

instance
derived instance

compiler pragma
inlining
specialization
language extension

abstract data type
abstract syntax tree
ambiguous type variable
binary search tree
binary tree
binding
BTree
canonical constructor
character literal
class
curly braces
curried function
deriving
eagerness
enumeration
evaluation
short-circuited
exported definitions
well-typed
first-match policy
precedence
composition
higher-order
generator
GHCi
guard
indentation
instance
IO
irrefutable pattern
labels
lazyness
comprehensions
concatenation
lexigographic order
module
module alias
module hierarchy
most general type
nested tuples
overloading
pairs
parametric constructor
partial application
partial function
pattern
ascription
linearity
overlapping
pattern matching
exhaustive pattern matching
polymorphic type
polymorphism
predicate
Prelude
qualified import
recursive type
reduction
rigid type variables
script file
side effects
inference
instantiation
well-founded recursion

thunk
`seq` forces evaluation
