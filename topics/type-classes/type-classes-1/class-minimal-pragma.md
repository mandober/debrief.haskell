# Haskell :: Reference :: Syntax :: Class :: MINIMAL pragma

A type class declares the methods a conforming type must implement. Sometimes, for various reasons, not every single method needs to be defined.

For example, the methods may be defined in terms of each other, which is the case with the `Eq` class and its two methods, `(==)` and `(/=)`. There, defining just one method automatically defines the other.

```hs
-- Defined in GHC.Classes
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool

  x == y = not (x /= y)
  x /= y = not (x == y)

  {-# MINIMAL (==) | (/=) #-}
```

Another reason is when a set of methods is equivalent to another set of methods, so only one set needs to be implemented.

The `MINIMAL` pragma, given inside a class declaration, prescribes exactly which of the class' methods the implementing type needs to define.

The `MINIMAL` pragma relayes this choice using logical conjunction and disjunction, with the names of methods as operands. In line with their general meaning in the language, a comma represents a conjunction, (, = ⋀), while a pipe is a disjunction, (| = ⋁).

The `MINIMAL` pragma then contains an expression consisting of these two operators, with method names as operands, and parenthesis are used for grouping.

For example, in the `Eq` class, the exp `(==) | (/=)` means either one or the other method. And in the `RandomGen` class, from the module `System.Random.Internal`, the choice is expressed as:

```hs
{-# MINIMAL split, (genWord32 | genWord64 | next, genRange) #-}
```

meaning `split ⋀ (genWord32 ⋁ genWord64 ⋁ next ⋀ genRange)`

So, it is necessary to implement the `split` method, AND one of the 3 sets of methods - where the first two sets are singletons and the last ine contains two elements.

Of course, The `MINIMAL` pragma just prescribes the minimum - the user is free to implement more or all methods as they see fit.

>In the end, an implementing type will have all the methods a class declares defined - some manually defined by the user and the others automatically generated by the GHC.

This automatic generation of compementary methods of a class is similar to a `deriving` clause associated with a type declaration, except that a `deriving` clause instructs GHC to automatically generate all the methods of a class, not just their subset. This effect of the `deriving` clause is limited to only some of the classes that the GHC has intimate knowledge of, although the set of the applicable classes that can be derived is growing ever larger. It also depends on the type being declared whether the `deriving` clause is supported at all - e.g. GHC won't allow the deriving of even the basic classes for types with recursive definitions - in which case the user may have better luck persuading GHC to derive the classes with a *standalone deriving clause*, which supports a more complex syntax for the deriving statement - most importantly, it supports the context where the user may declare the appropriate constraints.

There are several pragmas that expand the set of derivable classes, as well as the pragma that unlocks the support for deriving strategies.

And if none of that works, well sometimes you best do it yourself.
