# Costate Comonad

Another example of a Comonad is the dual of the `State` monad, called the `Costate` comonad or `Store` comonad.

We've seen before that the state monad is generated by the adjunction that defines the exponentials:

```js
L z = z × s
R a = s ⇒ a
```

We'll use the same adjunction to define the costate comonad; it is defined by the composition `L ∘ R`:

```js
L (R a) = (s ⇒ a) × s
```

Translating this to Haskell, we start with the adjunction between the `Product` functor on the left and the `Reader` functor or the right. Composing `Product` after `Reader` is equivalent to the following definition.

```hs
data Store s a = Store (s -> a) s
```

The *counit of the adjunction* taken at the object `a` is the morphism:

```js
εa :: ((s ⇒ a) × s) -> a
```

or, in Haskell notation:

```hs
data Store s a = Store (s -> a) s

-- counit of the adjunction taken at the object a is the morphism
counit (Prod (Reader f) s) = f s

-- This becomes extract
extract (Store f s) = f s

-- The unit of the adjunction is:
unit :: a -> Reader s (Product a s)
unit a = Reader (\ s -> Prod a s)
```


We construct δ, or `duplicate`, as the horizontal composition:

```hs
δ :: L ∘ R -> L ∘ R ∘ L ∘ R
δ = L ∘ η ∘ R
```

We have to sneak η through the leftmost `L`, which is the `Product` functor. It means acting with η, or `Store f`, on the left component of the pair (that's what `fmap` for `Product` would do). We get:

```hs
duplicate (Store f s) = Store (Store f) s
```

(Remember that, in the formula for δ, `L` and `R` stand for identity natural transformations whose components are identity morphisms.)


Here's the complete definition of the `Store` comonad:

```hs
instance Comonad (Store s) where
  extract   (Store f s) = f s
  duplicate (Store f s) = Store (Store f) s
```

You may think of the `Reader` part of `Store` as a generalized container of `a`s that are keyed using elements of the type `s`. For instance, if `s` is `Int`, `Reader Int a` is an infinite bidirectional stream of `a`s. Store pairs this container with a value of the key type. For instance, `Reader Int a` is paired with an `Int`. In this case, `extract` uses this integer to index into the infinite stream. You may think of the second component of `Store` as the current position.

Continuing with this example, `duplicate` creates a new infinite stream indexed by an `Int`. This stream contains streams as its elements. In particular, at the current position, it contains the original stream. But if you use some other `Int` (positive or negative) as the key, you'd obtain a shifted stream positioned at that new index.

In general, you can convince yourself that when `extract` acts on the `duplicate`d `Store` it produces the original `Store` (in fact, the identity law for the comonad states that `extract . duplicate = id`).

The `Store` comonad plays an important role as the theoretical basis for the `Lens` library. Conceptually, the `Store s a` comonad encapsulates the idea of "focusing" (like a lens) on a particular substructure of the date type `a` using the type `s` as an index.

In particular, a function of the type `a -> Store s a` is equivalent to a pair of functions:

```hs
set :: a -> s -> a
get :: a -> s
```

If `a` is a product type, `set` could be implemented as setting the field of type `s` inside of `a` while returning the modified version of `a`. Similarly, `get` could be implemented to read the value of the `s` field from `a`.
