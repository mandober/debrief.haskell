# Lexical Structure

https://www.haskell.org/onlinereport/haskell2010/haskellch2.html
https://wiki.haskell.org/Keywords

These notational conventions are used for presenting syntax:

[ğ˜±ğ˜¢ğ˜µğ˜µğ˜¦ğ˜³ğ˜¯]      optional, (?)   
{ğ˜±ğ˜¢ğ˜µğ˜µğ˜¦ğ˜³ğ˜¯}      zero or more repetitions, (*)   
(ğ˜±ğ˜¢ğ˜µğ˜µğ˜¦ğ˜³ğ˜¯)      grouping   
patâ‚ | patâ‚‚  choice   
patâŸ¨á´˜á´€á´›â€²âŸ©    elements generated by pat except those generated by á´˜á´€á´›â€²   
ğšğš’ğš‹ğš˜ğš—ğšŠğšŒğšŒğš’    terminal syntax in typewriter font   

* Haskell uses the Unicode character set. However, source programs are currently biased toward the ASCII charset as used in earlier versions


## Lexical Program Structure

program     := { lexeme | whitespace }
lexeme      := qvarid
             | qconid
             | qvarsym
             | qconsym
             | literal
             | special
             | reservedop
             | reservedid
literal     := integer | float | char | string
special     := **( ) [ ] { } , ; `**

whitespace  := whitestuff {whitestuff}
whitestuff  := whitechar | comment | ncomment
whitechar   := newline | vertab | space | tab | uniWhite
uniWhite    := any Unicode character defined as whitespace

tab         := horizontal tab
space       := space
vertab      := vertical tab
return      := carriage return
linefeed    := line feed
formfeed    := form feed
newline     := return linefeed | return | linefeed | formfeed

comment     := dashes [ any âŸ¨symbolâŸ© {any} ] newline
dashes      := `--` {`-`}
opencom     := `{-`
closecom    := `-}`
ncomment    := opencom ANY seq {ncomment ANY seq} closecom

ANY seq     := {ANY } âŸ¨{ANY } ( opencom | closecom ) {ANY }âŸ©
ANY         := graphic | whitechar
any         := graphic | space | tab

graphic     := small   | large | symbol | digit | special | **" '**

small       := ascSmall | uniSmall | **_**
ascSmall    := a-z
uniSmall    := any Unicode lowercase letter

large       := ascLarge | uniLarge
ascLarge    := A-Z
uniLarge    := any uppercase or titlecase Unicode letter
symbol      := ascSymbol | uniSymbol âŸ¨**_ " '**âŸ©

ascSymbol   := **! # $ % & â‹† + . / < = > ? @ \ ^ | - ~ :**
uniSymbol   := any Unicode symbol or punctuation
digit       := ascDigit | uniDigit
ascDigit    := 0-9
uniDigit    := any Unicode decimal digit
octit       := 0-7
hexit       := digit | a-f | A-F



* Lexical analysis uses the *maximal munch rule*: at each point, the longest possible lexeme satisfying the lexeme production is read. So, although `case` is a reserved word, `cases` is not. Similarly, although `=` is reserved, `==` and `~=` are not.

* Any kind of whitespace is also a proper delimiter for lexemes.

* Characters not in the category `ANY` are not valid in Haskell programs and should result in a lexing error.

* A line comment begins with a sequence of two or more consecutive dashes and extends to the following newline. The sequence of dashes *must not form part of a legal lexeme*. For example, `-->` or `|--` do not begin a comment, since both are legal lexemes; however `--foo` start a comment. **Always put a space after double dashes when they are meant to start a comment**.


## Identifiers

varid       := (small {small | large | digit | **'** })âŸ¨reservedidâŸ©
conid       := large  {small | large | digit | **'** }
reservedid  := case     of          _
               let      in          where
               if       then        else
               infix    infixl      infixr
               type     newtype     data
               module   import      do
               class    instance    deriving
               default  foreign

* an *identifier* consists of a letter followed by 0+ letters, digits, underscores and single quotes. Identifiers are lexically distinguished into two namespaces: start with a *lowercase* letter (var identifiers); start with an *upper-case* letter (ctor identifiers)

* underscore is treated as a lowercase letter, and can occur wherever a lowercase letter can. underscore by itself is a reserved identifier used as *wild card* in patterns. identifier starting with _ turns off related (var) warnings.


## Operators

varsym      := ( symbolâŸ¨:âŸ© {symbol} )âŸ¨reservedop | dashesâŸ©
consym      := ( : {symbol})âŸ¨reservedopâŸ©
reservedop  := **.. : :: = \ | <- -> @ ~ =>**



## Character and String Literals

char	â†’	' (graphicâŸ¨' | \âŸ© | space | escapeâŸ¨\&âŸ©) '
string	â†’	" {graphicâŸ¨" | \âŸ© | space | escape | gap} "
escape	â†’	\ ( charesc | ascii | decimal | o octal | x hexadecimal )
charesc	â†’	a | b | f | n | r | t | v | \ | " | ' | &
ascii	â†’	^cntrl | NUL | SOH | STX | ETX | EOT | ENQ | ACK
|	BEL | BS | HT | LF | VT | FF | CR | SO | SI | DLE
|	DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN
|	EM | SUB | ESC | FS | GS | RS | US | SP | DEL
cntrl	â†’	ascLarge | @ | [ | \ | ] | ^ | _
gap	â†’	\ whitechar {whitechar} \


### Char Literals

Character literals are written between single quotes, as in 'a', and strings between double quotes, as in "Hello".

Escape codes may be used in characters and strings to represent special characters.

* A single quote `'` may be used in a string, but must be escaped in a character; similarly, a double quote `"` may be used in a character, but must be escaped in a string. `\` must always be escaped.

* The category charesc also includes portable representations for the characters "alert" (\a), "backspace" (\b), "form feed" (\f), "new line" (\n), "carriage return" (\r), "horizontal tab" (\t), and "vertical tab" (\v).

* Escape characters for the Unicode character set, including control characters such as \^X, are also provided. Numeric escapes such as \137 are used to designate the character with decimal representation 137; octal (e.g. \o137) and hexadecimal (e.g. \x37) representations are also allowed.


### String Literals

* Consistent with the "maximal munch" rule, numeric escape characters in strings consist of all consecutive digits and may be of arbitrary length. Similarly, the one ambiguous ASCII escape code, "\SOH", is parsed as a string of length 1. The escape character \& is provided as a "null character" to allow strings such as "\137\&9" and "\SO\&H" to be constructed (both of length two). Thus "\&" is equivalent to "" and the character '\&' is disallowed. Further equivalences of characters are defined in Section 6.1.2.

* A string may include a "gap"-two backslants enclosing white characters-which is ignored. This allows one to write long strings on more than one line by writing a backslant at the end of one line and at the start of the next. For example,


```hs
x = "Here is a backslant \\ as well as \137, \
    \a numeric escape character, and \^X, a control character."

putStrLn x
-- Here is a backslant \ as well as , a numeric escape character, and , a control character.
```
