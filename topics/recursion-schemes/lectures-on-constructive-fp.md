# Lectures on Constructive Functional Programming
by Richard Bird, 1989 (pages: 70)

## Abstract

The subject of these lectures is *calculus of functions* for *deriving programs from their specifications*.

This calculus consists of a range of notions fro defining functions over data types together with their algebraic and other properties.

## 1. Basic concepts

### 1.0 Problem

The **Horner's rule** states the following equality:

abc + bc + c + 1 = 
c(ab + b + 1) + 1 = 
c(b(a + 1) + 1) + 1 = 
((a + 1)b + 1)c + 1

which generalizes to `n` term.

The Horner's rule turns out to be useful for our calculus because the interpretation of (+) and (√ó) need not be confined just to arithmetic, but the essential constraints are only that both ops are assoc and have identity (id of + is 0, id of √ó is 1).

### 1.1 Functions

Functions are assumed to be *total* (unless stated otherwise) and curryied. Function application is more binding than any other operation, so `f a ‚®Ä g b` means `(f a) ‚®Ä (g b)` and not `f (a ‚®Ä (g b))`. Here, `‚®Ä` denotes an arbitrary binop (‚®Å, ‚®Ç, ‚®Ä).

Bin ops may be *sectioned*:
- (‚®Ä) a b = a ‚®Ä b
- (a ‚®Ä) b = a ‚®Ä b
- (‚®Ä b) a = a ‚®Ä b

So if `‚®Ä : a -> b -> c` then
- (‚®Ä)    : a -> b -> c
- (a ‚®Ä)  : b -> c
- (‚®Ä b)  : a -> c

And
- `curry :: ((a, b) -> c) -> a -> b -> c`
- `uncurry :: (a -> b -> c) -> (a, b) -> c`

```hs
-- | mutual recursion defining nothing
(‚®Å) :: (a, b) -> c
(‚®Å) = uncurry (‚®Ä)

(‚®Ä) :: a -> b -> c
(‚®Ä) = curry (‚®Å)

x1 :: a -> c
x1 = let (‚®Ä) a b = curry (‚®Å) a b
     in (‚®Ä 2)

x2 :: b -> c
x2 = let (‚®Ä) a b = curry (‚®Å) a b
     in (1 ‚®Ä)

x3 :: a -> b -> c
x3 = let (‚®Ä) a b = curry (‚®Å) a b
     in (‚®Ä)
```

For example, a way to express that function composition is associative is to write:

>((g .) . (f .))  ===  ((f . g) .)

```hs
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(.) g f x = g (f x)

f :: a -> b -- is the same as f :: Œæ -> œï (may even unify to a -> a)
g :: b -> c -- is the same as g :: Œ∂ -> Œ≥ (may even unify to a -> a)

-- that is why these both have the same type:
(g . f) :: a -> c
(f . g) :: a -> c

-- sections:

-- (.)    :: (b -> c) -> (a -> b) -> (a -> c)
-- (.) g f x =   g           f        x
-- g . f =       g           f

-- because
(.)   :: (b -> c) -> (a -> b) -> (a -> c)
-- thus if (g :: b -> c) is fixed, what remains for (.) is
(g .) ::             (a -> b) -> (a -> c)
-- and  if (g :: a -> b) is fixed, what remains for (.) is
(f .) :: (a -> b)             -> (a -> c)

((g .) . (f .)) :: (a -> b) -> (a -> c)
((f . g) .)     :: (a -> b) -> (a -> c)
```

The identity element of a binary operator `‚®Å :: a √ó a -> a`, if exists, will be denoted by `œµ`; thus, `œµ ‚®Å a = a = a ‚®Å œµ`. The identity element of composition will be denoted by `id`. The constant function `konst :: a -> b -> a`.


### 1.2 Lists

Lists are the common cons-lists. The function `[‚àô] :: a -> [a]` makes a list out of a value, thus `[‚àô] a = [a]`. Concatenation is `‚´≤ :: [a] -> [a] -> [a]`. Usually (but not always) we assume the existence of the empty list, `[]`, which serves as identity of concatenation. The type of list, including the empty list, is `[a]`, and the type of list, excluding the empty list, is `[a]·ê©`. That is, `[a]·ê©` corresponds to `NonEmply` in Haskell.

Therefore
- _([a], ‚´≤, [])_ is a monoid
- _([a]·ê©, ‚´≤)_ is a semigroup

In order to specify functions over lists we need an additional assumption, namely that _([a], ‚´≤, [])_ is a **free monoid** generated by `a` under the assignment `[‚àô] :: a -> [a]`.

This algebraic statement is equivalent to the assertion that for each function `f :: a -> b`, and associative operator `‚®Å :: b √ó b -> b`, the following 3 equations specify a unique function `h :: [a] -> b`.
1. h [] = œµ
2. h [a] = f a
3. h (x ‚´≤ y) = g x ‚´≤ g y

```hs
h :: [a] -> b
h []         = œµ              -- (1)
h [a]        = f a            -- (2)
h (xs ++ ys) = g xs ++ g ys   -- (3)
  where
  f :: a -> b
  (‚®Å) :: b -> b -> b
```

In case œµ (identity element for the binop ‚®Å) is not defined, the last two equations define a unique function `h :: [a]·ê© -> b`.

Any function `h` satisfying the equation (1) and (3) is by definition an **homomorphism** from the monoid _([a], ‚´≤, [])_ to the monoid _([b], ‚®Å, œµ)_. 

One example of a homomorphism is provided by the function `# : [a] -> ‚Ñï`, which returns the length of the list:

```hs
# []    = 0
# [a]   = 1
# x ‚´≤ y = # x + # y
```

(+) is assoc with id 0, so `(‚Ñï, +, 0)` is a monoid.

### 1.3 Bags and sets

Bags (multisets) are constructed by adding the rule that `‚´≤` is assoc and commutative. Bag union is `‚´≤` or `‚äå`. Singleton bag is `‚üÖa‚üÜ`.

Sets are constructed by adding the rule that `‚´≤` is assoc, commutative and idempotent. Aet union is `‚´≤` or `‚à™`. Singleton set is `{a}`

A similar algebraic statement about freeness holds for lists, bags and sets.

We assume that `(‚üÖa‚üÜ, ‚äå, ‚üÖ‚üÜ)` is a **free commutative monoid** generated by `a` under the assignment `‚üÖ‚àô‚üÜ : a -> ‚üÖa‚üÜ`. In case of bags this means that for each function `f : a -> b` and associative and commutative binop `‚®Å : b √ó b -> b`, the following equations define a unique function `h : ‚üÖa‚üÜ -> b`.

```hs
h ‚üÖ‚üÜ      = œµ
h ‚üÖa‚üÜ     = a
h (x ‚äå y) = h x ‚äå h y
```

We assume that `({a}, ‚à™, {})` is a **free commutative and idempotent monoid** generated by `a` under the assignment `{‚àô} : a -> {a}`. In case of sets this means that for each function `f : a -> b` and associative, commutative and idempotent binop `‚®Å : b √ó b -> b`, the following equations define a unique function `h : {a} -> b`.

```hs
h {}      = œµ
h {a}     = a
h (x ‚à™ y) = h x ‚à™ h y
```

For example, repetitions are counted toward the size of a bag, so the function `#` is similar to the one for lists.

```hs
# ‚üÖ‚üÜ      = 0
# ‚üÖa‚üÜ     = 1
# (x ‚äå y) = # x + # y
```

However (+) is not idempotent, so the same equations cannot define the size function for sets (unless a set representation is guaranteed to be normalized, i.e. free of repetitions).

### 1.4 Map

The map operator `*` is used infix, and on lists it is defined

```hs
-- m a t h
f * [a, b, c] = [f a, f b, f c]

-- h a s k e l l
f <$> [a, b, c] = [f a, f b, f c]
```

The map operator `*` can be specified by the following 3 equations:

Note: in this paper, the map operator `*` is like `map` in Haskell, but the 3rd equation always defines things in terms of concatenation of 2 lists `(x ‚´≤ y)` (as if a list is deconstructed into 2 concatenated lists), thus the 3rd equation for map `*` maps over lists, `x` and `y`, as `f * (x ‚´≤ y)` (i.e. the left-hand side does not contain the usual destructuring pattern `(x:xs)`, but concatenation of lists `xs ++ ys`)

```hs
(*) :: (a -> b) -> [[a]] -> [[b]]
-- m a t h
f * []        = []
f * [a]       = [f a]
f * (xs ‚´≤ ys) = (f * xs) ‚´≤ (f * ys)

-- h a s k e l l
(*) :: (a -> b) -> [[a]] -> [[b]]
f * []         = []
f * [x]        = [f x]
f * (xs ++ ys) = (f * xs) ++ (f * ys)

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs
```

Thus, for `f : a -> b` the function `f *` is a homomorphism from `([a], ‚´≤, [])` to `([b], ‚´≤, [])`. *This function is a homomorphism on bags, sets and lists*.


The map operator *distributes through composition*:

>((f ‚àò g) *) = (f *) ‚àò (g *)                 [map-distro]

which is expressed in Haskell as

```hs
((f . g) <$>) = (f <$>) . (g <$>)       { map-distro }
-- since map ‚âà fmap = (<$>)
map (f . g) = map f . map g               { map-distro }
```

### 1.5 Reduce

The fold or reduce operator, denoted by `/`, takes a binop and a list:

>‚®Å / [a, b, c, ‚Ä¶, z] = a ‚®Å b ‚®Å c ‚®Å ‚Ä¶ ‚®Å z

```hs
‚®Å / a : b : c : [] = a ‚®Å b ‚®Å c
```

We specify `‚®Å /`, where `‚®Å` is associative, by 3 equations

```hs
‚®Å / [] = œµ
‚®Å / [a] = a
‚®Å / (x ‚´≤ y) = (‚®Å / x) ‚®Å (‚®Å / x)
```

The fold operator here corresponds to Haskell's `foldr1` which is a variant of `foldr` without a base case, and thus may only be applied to non-empty structures (e.g. `NonEmpty` version of list). And the section `‚®Å /` can be expressed as a prefix function `foldr1 (‚®Å)`, or as sections `(foldr1 ‚®Å)`, that is, as `(‚®Å ‚´Ω)` (binop `‚®Å` should have less porecedence thatn the fold op `‚´Ω`), with the following definitions.

```hs
-- arbitrary assoc. binop
(‚®Å) :: [a] -> [a] -> [a]
(‚®Å) = (‚´≤)
infixr 5 ‚®Å, ‚´≤

-- ‚ãò ‚ãô  ‚â™ ‚®†   ‚®û ‚®†   ‚™¶ ‚™ß   ‚™° ‚™¢  ‚™ª ‚™º   ‚™£   ‚â∂

-- fold operator, (‚´ª) = foldr1
(‚´ª), foldr1 :: (a -> a -> a) -> [a] -> a
(‚´ª) = foldr1

-- or, the definition fold operator (‚´ª)
-- panic! on empty list!
(‚´ª) :: (a -> b) -> [a] -> [b]
f ‚´ª []     = error "panic"
f ‚´ª (x:xs) = f x : ((‚´ª) f xs)
infixr 6 ‚´ª

-- using fold in a section
sect :: [Int] -> [Int -> Int]
sect = ((+) ‚´ª)

x1 :: [Int -> Int]
x1 = (+) ‚´ª [1..4]

section :: [[a]] -> [[a] -> [a]]
section = ((‚´≤) ‚´ª)
--   not: ((‚´≤) (‚´ª)) -- ERROR!
```

Note: In Haskell, when sectioning the fold operator `‚´ª`, it is left unparanthesized, but the binop must be paranthesized, `((+) ‚´ª)`.

Note: The section presented here `‚®Å /` corresponds to `((‚®Å) ‚´ª)` in Haskell.


If the binop `‚®Å` is commutative as well, then `‚®Å /` can be applied to bags. If `‚®Å` is additionally idempotent as well, then `‚®Å /` can be applied to sets.

If `‚®Å` has no identity element, then we can regard `‚®Å /` as a function of type `‚®Å / : [a]·ê© -> a`. Alternatively, we can invent an identity element and adjoin it to the set/type `a`. With little care, the domain can almost always be expanded with such fictitious id elements.

For example, the minimum operator, `‚Üì`, defined by
>a ‚Üì b = a ‚â§ b ? a : b

has no identity element in ‚Ñù. However, we can adjoin infinity (`‚àû`) as its identity element, which satisfies only that: `‚àû ‚Üì x = x = x ‚Üì ‚àû`, for all `x` in `‚Ñù ‚ãÉ {‚àû}`. This way, inconsistency is avoided.

The two useful functions without identity element (we'll leave them without one) are `head` and `last` functions, defined as the sections `‚â™ /` and `‚®† /`, where the operators "left", `‚â™`, and "right", `‚®†`, are defined as follows. In fact `‚â™` is `K`, while `‚®†` is `KI` or `flip K` (i.e. `C K`).

```hs
-- ‚®† operator, "left"
(‚â™) :: a -> a -> a
a ‚â™ b = a   -- or
(‚â™) = const

-- ‚®† operator, "right"
(‚®†) :: a -> a -> a
a ‚®† b = b  -- or
(‚®†) = flip const


-- "head" function as a section w/ reduce op: ‚â™ /
car :: [a] -> [a -> a]
car = ((‚â™) ‚´ª)

-- "tail" function as a section w/ reduce op: ‚®† /
cnd :: [a] -> [a -> a]
cnd = ((‚®†) ‚´ª)
```




## 2. Homomorphisms

## 3. Left reductions

## 4. Arrays

### 4.0 Problem

Let array `x` have elements in the set ùîπ = {0, 1}. Required is an efficient algorithm for computing the area of the largest rectangle (i.e. contiguous subarray) of `x`, all of whose elements are 1.

### 4.1 Binoids

Suppose `a` is a set closed under 2 partial ops `+` and `√ó` such that
1. `+` and `√ó` are associative in the sense that each of the equations   
    a + (b + c) = (a + b) + c   
    a √ó (b √ó c) = (a √ó b) √ó c   
 hold whenever both sides of the equation are defined.
2. `+` and `√ó` satisfy the equation   
    __(a + b) √ó (c + d) = (a √ó c) + (b √ó d)__   
  whenever both sides of the equation are defined.   
  We refer to this property by saying that *(+) abides by (√ó)*.

There is no standard name for this structure so we call it a *binoid*.

#### Examples of binoids

- (a, ‚®Å, ‚®Å), where (‚®Å) is associative and commutative
- (a, <<, <<), with (+) = (√ó) = (<<)
- (a, >>, >>), with (+) = (√ó) = (>>)
- (a, >>, <<), with (+) = (>>) and (√ó) = (<<)
- (a, <<, >>), with (+) = (<<) and (√ó) = (>>)
where (>>) and (<<) are associative but not commutative



* [Ex.1] Let `‚®Å : a √ó a -> a` be associative and commutative. Then it abides by itself, so __(a, ‚®Å, ‚®Å)__ is a binoid.

- (+) = (‚®Å)
- (√ó) = (‚®Å)

```hs
(a ‚®Å b) ‚®Å (c ‚®Å d)  =  (a ‚®Å c) ‚®Å (b ‚®Å d)
 a ‚®Å b  ‚®Å  c ‚®Å d   =  (a ‚®Å c) ‚®Å (b ‚®Å d)
 a ‚®Å c  ‚®Å  b ‚®Å d   =  (a ‚®Å c) ‚®Å (b ‚®Å d)
(a ‚®Å c) ‚®Å (b ‚®Å d)  =  (a ‚®Å c) ‚®Å (b ‚®Å d)
```


* [Ex.2.1] The operator `<<` is defined as `a << b = a`. It is associative but not commutative. Nevertheless the structure __(a, <<, <<)__ is a binoid.

- (+) = (<<)
- (√ó) = (<<)

Since both sides reduce to `a`, we have that `<<` abides by itself.
```hs
(a << b) << (c << d) = (a << c) << (b << d)
 a       <<  c       =  a        << b
 a                   =  a
```

* [Ex.2.2] Similarly, the operator `>>`, defined by `a >> b = b`, has the same properties so __(a, >>, >>)__ is also a binoid.

- (+) = (>>)
- (√ó) = (>>)


Since both sides reduce to `d`, we have that `>>` abides by itself.
```hs
(a >> b) >> (c >> d) = (a >> c) >> (b >> d)
      b  >>       d  =       c  >>       d
                  d  =                   d
```

* [Ex.3.1] The structure __(a, >>, <<)__ is a binoid.

- (+) = (>>)
- (√ó) = (<<)

Since both sides reduce to `b`, we have that `>>` abides by `<<`.
```hs
(a >> b) << (c >> d) = (a << c) >> (b << d)
      b  <<       d  =  a       >>  b
      b              =              b
```

* [Ex.3.2] The mirror structure __(a, <<, >>)__ is also a binoid (although it is not mentioned in the book).

- (+) = (<<)
- (√ó) = (>>)

Since both sides reduce to `c`, we have that `<<` abides by `>>`.
```hs
(a << b) >> (c << d)  =  (a >> c) << (b >> d)
 a       >>  c        =        c  <<       d
             c        =        c
```

* [Ex.4] Define the partial operator `‚Ä¢` by the equation

`a ‚Ä¢ b = a` if `a = b`

So, `a ‚Ä¢ b` reduces to `a` if `a` and `b` are equal; otherwise the operation is not defined (since it is partial).

```hs
(‚Ä¢) :: a -> a -> a
a ‚Ä¢ b | a == b    = a
      | otherwise = error "(‚Ä¢) not defined when a /= b"
```

The operator `‚Ä¢` is associative because

    a ‚Ä¢ (b ‚Ä¢ c) = (a ‚Ä¢ b) ‚Ä¢ c

whenever both sides are defined, i.e. when a = b = c.

Let `‚®Å : a √ó a -> a` be the same associative operator. Then __(a, ‚®Å, ‚Ä¢)__ is a binoid.

We have
- (+) = (‚®Å)
- (√ó) = (‚Ä¢)

such that

    (a ‚®Å b) ‚Ä¢ (c ‚®Å d) = (a ‚Ä¢ c) ‚®Å (b ‚Ä¢ d)

whenever both sides are defined. The rhs is defined just in case a=c and b=d, and its value is then `a ‚®Å b`. The lhs is defined just in case `a ‚®Å b = c ‚®Å d` and its value is then `a ‚®Å b`.

Notice that lhs can be defined without the rhs being defined.

### 4.2 Arrays
