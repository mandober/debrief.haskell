# Lectures on Constructive Functional Programming
by Richard Bird, 1989 (pages: 70)

## Abstract

The subject of these lectures is *calculus of functions* for *deriving programs from their specifications*.

This calculus consists of a range of notions fro defining functions over data types together with their algebraic and other properties.

## 1. Basic concepts

### 1.0 Problem

The **Horner's rule** states the following equality:

abc + bc + c + 1 = 
c(ab + b + 1) + 1 = 
c(b(a + 1) + 1) + 1 = 
((a + 1)b + 1)c + 1

which generalizes to `n` term.

The Horner's rule turns out to be useful for our calculus because the interpretation of (+) and (×) need not be confined just to arithmetic, but the essential constraints are only that both ops are assoc and have identity (id of + is 0, id of × is 1).

### 1.1 Functions

Functions are assumed to be *total* (unless stated otherwise) and curryied. Function application is more binding than any other operation, so `f a ⨀ g b` means `(f a) ⨀ (g b)` and not `f (a ⨀ (g b))`. Here, `⨀` denotes an arbitrary binop (⨁, ⨂, ⨀).

Bin ops may be *sectioned*:
- (⨀) a b = a ⨀ b
- (a ⨀) b = a ⨀ b
- (⨀ b) a = a ⨀ b

So if `⨀ : a -> b -> c` then
- (⨀)    : a -> b -> c
- (a ⨀)  : b -> c
- (⨀ b)  : a -> c

And
- `curry :: ((a, b) -> c) -> a -> b -> c`
- `uncurry :: (a -> b -> c) -> (a, b) -> c`

```hs
-- | mutual recursion defining nothing
(⨁) :: (a, b) -> c
(⨁) = uncurry (⨀)

(⨀) :: a -> b -> c
(⨀) = curry (⨁)

x1 :: a -> c
x1 = let (⨀) a b = curry (⨁) a b
     in (⨀ 2)

x2 :: b -> c
x2 = let (⨀) a b = curry (⨁) a b
     in (1 ⨀)

x3 :: a -> b -> c
x3 = let (⨀) a b = curry (⨁) a b
     in (⨀)
```

For example, a way to express that function composition is associative is to write:

>((g .) . (f .))  ===  ((f . g) .)

```hs
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(.) g f x = g (f x)

f :: a -> b -- is the same as f :: ξ -> ϕ (may even unify to a -> a)
g :: b -> c -- is the same as g :: ζ -> γ (may even unify to a -> a)

-- that is why these both have the same type:
(g . f) :: a -> c
(f . g) :: a -> c

-- sections:

-- (.)    :: (b -> c) -> (a -> b) -> (a -> c)
-- (.) g f x =   g           f        x
-- g . f =       g           f

-- because
(.)   :: (b -> c) -> (a -> b) -> (a -> c)
-- thus if (g :: b -> c) is fixed, what remains for (.) is
(g .) ::             (a -> b) -> (a -> c)
-- and  if (g :: a -> b) is fixed, what remains for (.) is
(f .) :: (a -> b)             -> (a -> c)

((g .) . (f .)) :: (a -> b) -> (a -> c)
((f . g) .)     :: (a -> b) -> (a -> c)
```

The identity element of a binary operator `⨁ :: a × a -> a`, if exists, will be denoted by `ϵ`; thus, `ϵ ⨁ a = a = a ⨁ ϵ`. The identity element of composition will be denoted by `id`. The constant function `konst :: a -> b -> a`.


### 1.2 Lists

Lists are the common cons-lists. The function `[∙] :: a -> [a]` makes a list out of a value, thus `[∙] a = [a]`. Concatenation is `⫲ :: [a] -> [a] -> [a]`. Usually (but not always) we assume the existence of the empty list, `[]`, which serves as identity of concatenation. The type of list, including the empty list, is `[a]`, and the type of list, excluding the empty list, is `[a]ᐩ`. That is, `[a]ᐩ` corresponds to `NonEmply` in Haskell.

Therefore
- _([a], ⫲, [])_ is a monoid
- _([a]ᐩ, ⫲)_ is a semigroup

In order to specify functions over lists we need an additional assumption, namely that _([a], ⫲, [])_ is a **free monoid** generated by `a` under the assignment `[∙] :: a -> [a]`.

This algebraic statement is equivalent to the assertion that for each function `f :: a -> b`, and associative operator `⨁ :: b × b -> b`, the following 3 equations specify a unique function `h :: [a] -> b`.
1. h [] = ϵ
2. h [a] = f a
3. h (x ⫲ y) = g x ⫲ g y

```hs
h :: [a] -> b
h []         = ϵ              -- (1)
h [a]        = f a            -- (2)
h (xs ++ ys) = g xs ++ g ys   -- (3)
  where
  f :: a -> b
  (⨁) :: b -> b -> b
```

In case ϵ (identity element for the binop ⨁) is not defined, the last two equations define a unique function `h :: [a]ᐩ -> b`.

Any function `h` satisfying the equation (1) and (3) is by definition an **homomorphism** from the monoid _([a], ⫲, [])_ to the monoid _([b], ⨁, ϵ)_. 

One example of a homomorphism is provided by the function `# : [a] -> ℕ`, which returns the length of the list:

```hs
# []    = 0
# [a]   = 1
# x ⫲ y = # x + # y
```

(+) is assoc with id 0, so `(ℕ, +, 0)` is a monoid.

### 1.3 Bags and sets

Bags (multisets) are constructed by adding the rule that `⫲` is assoc and commutative. Bag union is `⫲` or `⊌`. Singleton bag is `⟅a⟆`.

Sets are constructed by adding the rule that `⫲` is assoc, commutative and idempotent. Aet union is `⫲` or `∪`. Singleton set is `{a}`

A similar algebraic statement about freeness holds for lists, bags and sets.

We assume that `(⟅a⟆, ⊌, ⟅⟆)` is a **free commutative monoid** generated by `a` under the assignment `⟅∙⟆ : a -> ⟅a⟆`. In case of bags this means that for each function `f : a -> b` and associative and commutative binop `⨁ : b × b -> b`, the following equations define a unique function `h : ⟅a⟆ -> b`.

```hs
h ⟅⟆      = ϵ
h ⟅a⟆     = a
h (x ⊌ y) = h x ⊌ h y
```

We assume that `({a}, ∪, {})` is a **free commutative and idempotent monoid** generated by `a` under the assignment `{∙} : a -> {a}`. In case of sets this means that for each function `f : a -> b` and associative, commutative and idempotent binop `⨁ : b × b -> b`, the following equations define a unique function `h : {a} -> b`.

```hs
h {}      = ϵ
h {a}     = a
h (x ∪ y) = h x ∪ h y
```

For example, repetitions are counted toward the size of a bag, so the function `#` is similar to the one for lists.

```hs
# ⟅⟆      = 0
# ⟅a⟆     = 1
# (x ⊌ y) = # x + # y
```

However (+) is not idempotent, so the same equations cannot define the size function for sets (unless a set representation is guaranteed to be normalized, i.e. free of repetitions).

### 1.4 Map

The map operator `*` is used infix, and on lists it is defined

```hs
-- m a t h
f * [a, b, c] = [f a, f b, f c]

-- h a s k e l l
f <$> [a, b, c] = [f a, f b, f c]
```

The map operator `*` can be specified by the following 3 equations:

Note: in this paper, the map operator `*` is like `map` in Haskell, but the 3rd equation always defines things in terms of concatenation of 2 lists `(x ⫲ y)` (as if a list is deconstructed into 2 concatenated lists), thus the 3rd equation for map `*` maps over lists, `x` and `y`, as `f * (x ⫲ y)` (i.e. the left-hand side does not contain the usual destructuring pattern `(x:xs)`, but concatenation of lists `xs ++ ys`)

```hs
(*) :: (a -> b) -> [[a]] -> [[b]]
-- m a t h
f * []        = []
f * [a]       = [f a]
f * (xs ⫲ ys) = (f * xs) ⫲ (f * ys)

-- h a s k e l l
(*) :: (a -> b) -> [[a]] -> [[b]]
f * []         = []
f * [x]        = [f x]
f * (xs ++ ys) = (f * xs) ++ (f * ys)

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs
```

Thus, for `f : a -> b` the function `f *` is a homomorphism from `([a], ⫲, [])` to `([b], ⫲, [])`. *This function is a homomorphism on bags, sets and lists*.


The map operator *distributes through composition*:

>((f ∘ g) *) = (f *) ∘ (g *)                 [map-distro]

which is expressed in Haskell as

```hs
((f . g) <$>) = (f <$>) . (g <$>)       { map-distro }
-- since map ≈ fmap = (<$>)
map (f . g) = map f . map g               { map-distro }
```

### 1.5 Reduce

The fold or reduce operator, denoted by `/`, takes a binop and a list:

>⨁ / [a, b, c, …, z] = a ⨁ b ⨁ c ⨁ … ⨁ z

```hs
⨁ / a : b : c : [] = a ⨁ b ⨁ c
```

We specify `⨁ /`, where `⨁` is associative, by 3 equations

```hs
⨁ / [] = ϵ
⨁ / [a] = a
⨁ / (x ⫲ y) = (⨁ / x) ⨁ (⨁ / x)
```

The fold operator here corresponds to Haskell's `foldr1` which is a variant of `foldr` without a base case, and thus may only be applied to non-empty structures (e.g. `NonEmpty` version of list). And the section `⨁ /` can be expressed as a prefix function `foldr1 (⨁)`, or as sections `(foldr1 ⨁)`, that is, as `(⨁ ⫽)` (binop `⨁` should have less porecedence thatn the fold op `⫽`), with the following definitions.

```hs
-- arbitrary assoc. binop
(⨁) :: [a] -> [a] -> [a]
(⨁) = (⫲)
infixr 5 ⨁, ⫲

-- ⋘ ⋙  ≪ ⨠   ⨞ ⨠   ⪦ ⪧   ⪡ ⪢  ⪻ ⪼   ⪣   ≶

-- fold operator, (⫻) = foldr1
(⫻), foldr1 :: (a -> a -> a) -> [a] -> a
(⫻) = foldr1

-- or, the definition fold operator (⫻)
-- panic! on empty list!
(⫻) :: (a -> b) -> [a] -> [b]
f ⫻ []     = error "panic"
f ⫻ (x:xs) = f x : ((⫻) f xs)
infixr 6 ⫻

-- using fold in a section
sect :: [Int] -> [Int -> Int]
sect = ((+) ⫻)

x1 :: [Int -> Int]
x1 = (+) ⫻ [1..4]

section :: [[a]] -> [[a] -> [a]]
section = ((⫲) ⫻)
--   not: ((⫲) (⫻)) -- ERROR!
```

Note: In Haskell, when sectioning the fold operator `⫻`, it is left unparanthesized, but the binop must be paranthesized, `((+) ⫻)`.

Note: The section presented here `⨁ /` corresponds to `((⨁) ⫻)` in Haskell.


If the binop `⨁` is commutative as well, then `⨁ /` can be applied to bags. If `⨁` is additionally idempotent as well, then `⨁ /` can be applied to sets.

If `⨁` has no identity element, then we can regard `⨁ /` as a function of type `⨁ / : [a]ᐩ -> a`. Alternatively, we can invent an identity element and adjoin it to the set/type `a`. With little care, the domain can almost always be expanded with such fictitious id elements.

For example, the minimum operator, `↓`, defined by
>a ↓ b = a ≤ b ? a : b

has no identity element in ℝ. However, we can adjoin infinity (`∞`) as its identity element, which satisfies only that: `∞ ↓ x = x = x ↓ ∞`, for all `x` in `ℝ ⋃ {∞}`. This way, inconsistency is avoided.

The two useful functions without identity element (we'll leave them without one) are `head` and `last` functions, defined as the sections `≪ /` and `⨠ /`, where the operators "left", `≪`, and "right", `⨠`, are defined as follows. In fact `≪` is `K`, while `⨠` is `KI` or `flip K` (i.e. `C K`).

```hs
-- ⨠ operator, "left"
(≪) :: a -> a -> a
a ≪ b = a   -- or
(≪) = const

-- ⨠ operator, "right"
(⨠) :: a -> a -> a
a ⨠ b = b  -- or
(⨠) = flip const


-- "head" function as a section w/ reduce op: ≪ /
car :: [a] -> [a -> a]
car = ((≪) ⫻)

-- "tail" function as a section w/ reduce op: ⨠ /
cnd :: [a] -> [a -> a]
cnd = ((⨠) ⫻)
```




## 2. Homomorphisms

## 3. Left reductions

## 4. Arrays

### 4.0 Problem

Let array `x` have elements in the set 𝔹 = {0, 1}. Required is an efficient algorithm for computing the area of the largest rectangle (i.e. contiguous subarray) of `x`, all of whose elements are 1.

### 4.1 Binoids

Suppose `a` is a set closed under 2 partial ops `+` and `×` such that
1. `+` and `×` are associative in the sense that each of the equations   
    a + (b + c) = (a + b) + c   
    a × (b × c) = (a × b) × c   
 hold whenever both sides of the equation are defined.
2. `+` and `×` satisfy the equation   
    __(a + b) × (c + d) = (a × c) + (b × d)__   
  whenever both sides of the equation are defined.   
  We refer to this property by saying that *(+) abides by (×)*.

There is no standard name for this structure so we call it a *binoid*.

#### Examples of binoids

- (a, ⨁, ⨁), where (⨁) is associative and commutative
- (a, <<, <<), with (+) = (×) = (<<)
- (a, >>, >>), with (+) = (×) = (>>)
- (a, >>, <<), with (+) = (>>) and (×) = (<<)
- (a, <<, >>), with (+) = (<<) and (×) = (>>)
where (>>) and (<<) are associative but not commutative



* [Ex.1] Let `⨁ : a × a -> a` be associative and commutative. Then it abides by itself, so __(a, ⨁, ⨁)__ is a binoid.

- (+) = (⨁)
- (×) = (⨁)

```hs
(a ⨁ b) ⨁ (c ⨁ d)  =  (a ⨁ c) ⨁ (b ⨁ d)
 a ⨁ b  ⨁  c ⨁ d   =  (a ⨁ c) ⨁ (b ⨁ d)
 a ⨁ c  ⨁  b ⨁ d   =  (a ⨁ c) ⨁ (b ⨁ d)
(a ⨁ c) ⨁ (b ⨁ d)  =  (a ⨁ c) ⨁ (b ⨁ d)
```


* [Ex.2.1] The operator `<<` is defined as `a << b = a`. It is associative but not commutative. Nevertheless the structure __(a, <<, <<)__ is a binoid.

- (+) = (<<)
- (×) = (<<)

Since both sides reduce to `a`, we have that `<<` abides by itself.
```hs
(a << b) << (c << d) = (a << c) << (b << d)
 a       <<  c       =  a        << b
 a                   =  a
```

* [Ex.2.2] Similarly, the operator `>>`, defined by `a >> b = b`, has the same properties so __(a, >>, >>)__ is also a binoid.

- (+) = (>>)
- (×) = (>>)


Since both sides reduce to `d`, we have that `>>` abides by itself.
```hs
(a >> b) >> (c >> d) = (a >> c) >> (b >> d)
      b  >>       d  =       c  >>       d
                  d  =                   d
```

* [Ex.3.1] The structure __(a, >>, <<)__ is a binoid.

- (+) = (>>)
- (×) = (<<)

Since both sides reduce to `b`, we have that `>>` abides by `<<`.
```hs
(a >> b) << (c >> d) = (a << c) >> (b << d)
      b  <<       d  =  a       >>  b
      b              =              b
```

* [Ex.3.2] The mirror structure __(a, <<, >>)__ is also a binoid (although it is not mentioned in the book).

- (+) = (<<)
- (×) = (>>)

Since both sides reduce to `c`, we have that `<<` abides by `>>`.
```hs
(a << b) >> (c << d)  =  (a >> c) << (b >> d)
 a       >>  c        =        c  <<       d
             c        =        c
```

* [Ex.4] Define the partial operator `•` by the equation

`a • b = a` if `a = b`

So, `a • b` reduces to `a` if `a` and `b` are equal; otherwise the operation is not defined (since it is partial).

```hs
(•) :: a -> a -> a
a • b | a == b    = a
      | otherwise = error "(•) not defined when a /= b"
```

The operator `•` is associative because

    a • (b • c) = (a • b) • c

whenever both sides are defined, i.e. when a = b = c.

Let `⨁ : a × a -> a` be the same associative operator. Then __(a, ⨁, •)__ is a binoid.

We have
- (+) = (⨁)
- (×) = (•)

such that

    (a ⨁ b) • (c ⨁ d) = (a • c) ⨁ (b • d)

whenever both sides are defined. The rhs is defined just in case a=c and b=d, and its value is then `a ⨁ b`. The lhs is defined just in case `a ⨁ b = c ⨁ d` and its value is then `a ⨁ b`.

Notice that lhs can be defined without the rhs being defined.

### 4.2 Arrays
