# Parametric polymorphism - Wikipedia

> In programming languages and type theory, parametric polymorphism is a way to make a language more expressive, while still maintaining full static type-safety. Using parametric polymorphism, a function or a data type can be written generically so that it can handle values identically without depending on their type.[1] Such functions and data types are called generic functions and generic datatypes respectively and form the basis of generic programming.

In [programming languages](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Programming_language) and [type theory](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_theory "Type theory"), **parametric polymorphism** is a way to make a language more expressive, while still maintaining full static [type-safety](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type-safety "Type-safety"). Using parametric [polymorphism](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Polymorphism_(computer_science)), a function or a data type can be written generically so that it can handle values _identically_ without depending on their type.[\[1\]](#cite_note-FOOTNOTEPierce2002-1) Such functions and data types are called **generic functions** and **generic datatypes** respectively and form the basis of [generic programming](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Generic_programming "Generic programming").

For example, a function `append` that joins two lists can be constructed so that it does not care about the type of elements: it can append lists of [integers](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Integer "Integer"), lists of [real numbers](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Real_number), lists of [strings](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/String_(computer_science) "String (computer science)"), and so on. Let the _type variable a_ denote the type of elements in the lists. Then `append` can be typed

`forall a. [a] × [a] -> [a]`

where `[a]` denotes the type of lists with elements of type _a_. We say that the type of `append` is _parameterized by a_ for all values of _a_. (Note that since there is only one type variable, the function cannot be applied to just any pair of lists: the pair, as well as the result list, must consist of the same type of elements) For each place where `append` is applied, a value is decided for _a_.

Following [Christopher Strachey](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Christopher_Strachey "Christopher Strachey"),[\[2\]](#cite_note-FOOTNOTEStrachey1967-2) parametric polymorphism may be contrasted with [ad hoc polymorphism](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Ad_hoc_polymorphism "Ad hoc polymorphism"), in which a single polymorphic function can have a number of distinct and potentially heterogeneous implementations depending on the type of argument(s) to which it is applied. Thus, ad hoc polymorphism can generally only support a limited number of such distinct types, since a separate implementation has to be provided for each type.

History\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=1 "Edit section: History")\]
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Parametric polymorphism was first introduced to programming languages in [ML](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ML_programming_language "ML programming language") in 1975.[\[3\]](#cite_note-3) Today it exists in [Standard ML](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Standard_ML "Standard ML"), [OCaml](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/OCaml "OCaml"), [F#](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/F_Sharp_(programming_language) "F Sharp (programming language)"), [Ada](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Ada_(programming_language) "Ada (programming language)"), [Haskell](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Haskell_(programming_language) "Haskell (programming language)"), [Mercury](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Mercury_(programming_language) "Mercury (programming language)"), [Visual Prolog](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Visual_Prolog "Visual Prolog"), [Scala](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Scala_(programming_language) "Scala (programming language)"), [Julia](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Julia_(programming_language) "Julia (programming language)"), [Python](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Python_(programming_language) "Python (programming language)"), [TypeScript](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/TypeScript "TypeScript"), [C++](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/C%2B%2B "C++") and others. [Java](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Java_(programming_language) "Java (programming language)"), [C#](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/C_Sharp_(programming_language) "C Sharp (programming language)"), [Visual Basic .NET](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Visual_Basic_.NET "Visual Basic .NET") and [Delphi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Object_Pascal "Object Pascal") have each introduced "generics" for parametric polymorphism. Some implementations of type polymorphism are superficially similar to parametric polymorphism while also introducing ad hoc aspects. One example is [C++](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/C%2B%2B "C++") [template specialization](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Template_specialization "Template specialization").

The most general form of polymorphism is "higher-rank [impredicative](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Impredicative "Impredicative") polymorphism". Two popular restrictions of this form are restricted rank polymorphism (for example, rank-1 or _prenex_ polymorphism) and predicative polymorphism. Together, these restrictions give "predicative prenex polymorphism", which is essentially the form of polymorphism found in ML and early versions of Haskell.

Higher-ranked polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=2 "Edit section: Higher-ranked polymorphism")\]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Rank-1 (prenex) polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=3 "Edit section: Rank-1 (prenex) polymorphism")\]

In a _[prenex](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Prenex "Prenex") polymorphic_ system, type variables may not be instantiated with polymorphic types.[\[4\]](#cite_note-4) This is very similar to what is called "ML-style" or "Let-polymorphism" (technically ML's Let-polymorphism has a few other syntactic restrictions). This restriction makes the distinction between polymorphic and non-polymorphic types very important; thus in predicative systems polymorphic types are sometimes referred to as _type schemas_ to distinguish them from ordinary (monomorphic) types, which are sometimes called _monotypes_. A consequence is that all types can be written in a form that places all quantifiers at the outermost (prenex) position. For example, consider the `append` function described above, which has type

`forall a. [a] × [a] -> [a]`

In order to apply this function to a pair of lists, a type must be substituted for the variable _a_ in the type of the function such that the type of the arguments matches up with the resulting function type. In an _impredicative_ system, the type being substituted may be any type whatsoever, including a type that is itself polymorphic; thus `append` can be applied to pairs of lists with elements of any type—even to lists of polymorphic functions such as `append` itself. Polymorphism in the language ML is predicative.\[_[citation needed](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_\] This is because predicativity, together with other restrictions, makes the [type system](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_system "Type system") simple enough that full [type inference](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_inference "Type inference") is always possible.

As a practical example, [OCaml](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/OCaml "OCaml") (a descendant or dialect of [ML](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ML_(programming_language) "ML (programming language)")) performs type inference and supports impredicative polymorphism, but in some cases when impredicative polymorphism is used, the system's type inference is incomplete unless some explicit type annotations are provided by the programmer.

### Rank-_k_ polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=4 "Edit section: Rank-k polymorphism")\]

<table role="presentation"><tbody><tr><td><a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/File:Wiki_letter_w_cropped.svg"><img alt="[icon]" src="chrome-extension://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png" decoding="async" width="20" height="14" srcset="chrome-extension://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/30px-Wiki_letter_w_cropped.svg.png 1.5x, chrome-extension://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/40px-Wiki_letter_w_cropped.svg.png 2x" data-file-width="44" data-file-height="31"></a></td><td><p>This section <b>needs expansion</b>. You can help by <a href="https://en.wikipedia.org/w/index.php?title=Parametric_polymorphism&amp;action=edit&amp;section=">adding to it</a>. <span><i>(<span>November 2013</span>)</i></span></p></td></tr></tbody></table>

For some fixed value _k_, rank-_k_ polymorphism is a system in which a quantifier may not appear to the left of _k_ or more arrows (when the type is drawn as a tree).[\[1\]](#cite_note-FOOTNOTEPierce2002-1)

[Type inference](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_inference "Type inference") for rank-2 polymorphism is decidable, but reconstruction for rank-3 and above is not.[\[5\]](#cite_note-FOOTNOTEPierce2002359-5)

### Rank-_n_ ("higher-rank") polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=5 "Edit section: Rank-n ("higher-rank") polymorphism")\]

<table role="presentation"><tbody><tr><td><a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/File:Wiki_letter_w_cropped.svg"><img alt="[icon]" src="chrome-extension://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png" decoding="async" width="20" height="14" srcset="chrome-extension://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/30px-Wiki_letter_w_cropped.svg.png 1.5x, chrome-extension://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/40px-Wiki_letter_w_cropped.svg.png 2x" data-file-width="44" data-file-height="31"></a></td><td><p>This section <b>needs expansion</b>. You can help by <a href="https://en.wikipedia.org/w/index.php?title=Parametric_polymorphism&amp;action=edit&amp;section=">adding to it</a>. <span><i>(<span>November 2013</span>)</i></span></p></td></tr></tbody></table>

Rank-_n_ polymorphism is polymorphism in which quantifiers may appear to the left of arbitrarily many arrows.

Predicativity and impredicativity\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=6 "Edit section: Predicativity and impredicativity")\]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Predicative polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=7 "Edit section: Predicative polymorphism")\]

In a predicative parametric polymorphic system, a type ![\tau ](https://wikimedia.org/api/rest_v1/media/math/render/svg/38a7dcde9730ef0853809fefc18d88771f95206c) containing a type variable ![\alpha ](https://wikimedia.org/api/rest_v1/media/math/render/svg/b79333175c8b3f0840bfb4ec41b8072c83ea88d3) may not be used in such a way that ![\alpha ](https://wikimedia.org/api/rest_v1/media/math/render/svg/b79333175c8b3f0840bfb4ec41b8072c83ea88d3) is instantiated to a polymorphic type. Predicative type theories include [Martin-Löf type theory](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Intuitionistic_type_theory "Intuitionistic type theory") and [NuPRL](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/NuPRL "NuPRL").

### Impredicative polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=8 "Edit section: Impredicative polymorphism")\]

_Impredicative polymorphism_ (also called _first-class polymorphism_) is the most powerful form of parametric polymorphism.[\[6\]](#cite_note-FOOTNOTEPierce2002340-6) A definition is said to be [impredicative](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Impredicativity "Impredicativity") if it is self-referential; in type theory this allows the instantiation of a variable in a type ![\tau ](https://wikimedia.org/api/rest_v1/media/math/render/svg/38a7dcde9730ef0853809fefc18d88771f95206c) with any type, including polymorphic types, such as ![\tau ](https://wikimedia.org/api/rest_v1/media/math/render/svg/38a7dcde9730ef0853809fefc18d88771f95206c) itself. An example of this is the [System F](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/System_F "System F") with the type variable _X_ in the type ![T = \forall X. X \to X](https://wikimedia.org/api/rest_v1/media/math/render/svg/244ff17fd2cd85aa147b61c5c8a4a120e39167fe), where _X_ could even refer to _T_ itself.

In [type theory](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_theory "Type theory"), the most frequently studied impredicative [typed λ-calculi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Typed_lambda_calculus "Typed lambda calculus") are based on those of the [lambda cube](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Lambda_cube "Lambda cube"), especially [System F](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/System_F "System F").[\[1\]](#cite_note-FOOTNOTEPierce2002-1)

Bounded parametric polymorphism\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=9 "Edit section: Bounded parametric polymorphism")\]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In 1985, [Luca Cardelli](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Luca_Cardelli "Luca Cardelli") and [Peter Wegner](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Peter_Wegner "Peter Wegner") recognized the advantages of allowing _bounds_ on the type parameters.[\[7\]](#cite_note-FOOTNOTECardelliWegner1985-7) Many operations require some knowledge of the data types, but can otherwise work parametrically. For example, to check whether an item is included in a list, we need to compare the items for equality. In [Standard ML](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Standard_ML), type parameters of the form _’’a_ are restricted so that the equality operation is available, thus the function would have the type _’’a_ × _’’a_ list → bool and _’’a_ can only be a type with defined equality. In [Haskell](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Haskell_(programming_language) "Haskell (programming language)"), bounding is achieved by requiring types to belong to a [type class](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_class "Type class"); thus the same function has the type ![{\scriptstyle Eq \, \alpha \, \Rightarrow \alpha \, \rightarrow \left[\alpha \right] \rightarrow Bool}](https://wikimedia.org/api/rest_v1/media/math/render/svg/70188ef71f3f8b09a5f69e3b75554ffd2b0851ee) in Haskell. In most object-oriented programming languages that support parametric polymorphism, parameters can be constrained to be [subtypes](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Subtyping) of a given type (see [Subtype polymorphism](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Subtype_polymorphism "Subtype polymorphism") and the article on [Generic programming](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Generic_programming "Generic programming")).

See also\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=10 "Edit section: See also")\]
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

*   [Parametricity](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Parametricity "Parametricity")
*   [Polymorphic recursion](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Polymorphic_recursion "Polymorphic recursion")
*   [Type class#Higher-kinded polymorphism](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Type_class#Higher-kinded_polymorphism)

Notes\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=11 "Edit section: Notes")\]
-----------------------------------------------------------------------------------------------------------------------------------------------------------

1.  ^ [Jump up to: _**a**_](#cite_ref-FOOTNOTEPierce2002_1-0) [_**b**_](#cite_ref-FOOTNOTEPierce2002_1-1) [_**c**_](#cite_ref-FOOTNOTEPierce2002_1-2) [Pierce 2002](#CITEREFPierce2002).
2.  **[^](#cite_ref-FOOTNOTEStrachey1967_2-0 "Jump up")** [Strachey 1967](#CITEREFStrachey1967).
3.  **[^](#cite_ref-3 "Jump up")** Milner, R., Morris, L., Newey, M. "A Logic for Computable Functions with reflexive and polymorphic types", _Proc. Conference on Proving and Improving Programs_, Arc-et-Senans (1975)
4.  **[^](#cite_ref-4)** Benjamin C. Pierce; Benjamin C. (Professor Pierce, University of Pennsylvania) (2002). [_Types and Programming Languages_](https://books.google.com/books?id=ti6zoAC9Ph8C). MIT Press. [ISBN](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ISBN_(identifier)) [978-0-262-16209-8](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Special:BookSources/978-0-262-16209-8 "Special:BookSources/978-0-262-16209-8").
5.  **[^](#cite_ref-FOOTNOTEPierce2002359_5-0 "Jump up")** [Pierce 2002](#CITEREFPierce2002), p. 359.
6.  **[^](#cite_ref-FOOTNOTEPierce2002340_6-0 "Jump up")** [Pierce 2002](#CITEREFPierce2002), p. 340.
7.  **[^](#cite_ref-FOOTNOTECardelliWegner1985_7-0)** [Cardelli & Wegner 1985](#CITEREFCardelliWegner1985).

References\[[edit](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/w/index.php?title=Parametric_polymorphism&action=edit&section=12 "Edit section: References")\]
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

*   [Strachey, Christopher](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Christopher_Strachey "Christopher Strachey") (1967), [_Fundamental Concepts in Programming Languages_](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Fundamental_Concepts_in_Programming_Languages "Fundamental Concepts in Programming Languages") (Lecture notes), Copenhagen: International Summer School in Computer Programming. Republished in: Strachey, Christopher (2000). _[Higher-Order and Symbolic Computation](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Higher-Order_and_Symbolic_Computation "Higher-Order and Symbolic Computation")_. **13**: 11–49. [doi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Doi_(identifier) "Doi (identifier)"):[10.1023/A:1010000313106](https://doi.org/10.1023%2FA%3A1010000313106).
*   [Hindley, J. Roger](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/J._Roger_Hindley "J. Roger Hindley") (1969), "The principal type scheme of an object in combinatory logic", _[Transactions of the American Mathematical Society](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Transactions_of_the_American_Mathematical_Society "Transactions of the American Mathematical Society")_, **146**: 29–60, [doi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Doi_(identifier) "Doi (identifier)"):[10.2307/1995158](https://doi.org/10.2307%2F1995158), [JSTOR](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/JSTOR_(identifier) "JSTOR (identifier)") [1995158](chrome-extension://www.jstor.org/stable/1995158), [MR](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/MR_(identifier) "MR (identifier)") [0253905](chrome-extension://www.ams.org/mathscinet-getitem?mr=0253905).
*   [Girard, Jean-Yves](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Jean-Yves_Girard "Jean-Yves Girard") (1971). "Une Extension de l'Interpretation de Gödel à l'Analyse, et son Application à l'Élimination des Coupures dans l'Analyse et la Théorie des Types". _Proceedings of the Second Scandinavian Logic Symposium_ (in French). Amsterdam. pp. 63–92. [doi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/S0049-237X(08)70843-7](https://doi.org/10.1016%2FS0049-237X%2808%2970843-7).
*   [Girard, Jean-Yves](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Jean-Yves_Girard "Jean-Yves Girard") (1972), _Interprétation fonctionnelle et élimination des coupures de l'arithmétique d'ordre supérieur_ (Ph.D. thesis) (in French), Université Paris 7.
*   [Reynolds, John C.](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/John_C._Reynolds) (1974), "Towards a Theory of Type Structure", _Colloque Sur la Programmation_, [Lecture Notes in Computer Science](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Lecture_Notes_in_Computer_Science "Lecture Notes in Computer Science"), Paris, **19**: 408–425, [doi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Doi_(identifier)):[10.1007/3-540-06859-7\_148](https://doi.org/10.1007%2F3-540-06859-7_148), [ISBN](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-540-06859-4](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Special:BookSources/978-3-540-06859-4 "Special:BookSources/978-3-540-06859-4").
*   [Milner, Robin](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Robin_Milner "Robin Milner") (1978). ["A Theory of Type Polymorphism in Programming"](https://www.pure.ed.ac.uk/ws/files/15143545/1_s2.0_0022000078900144_main.pdf) (PDF). _[Journal of Computer and System Sciences](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Journal_of_Computer_and_System_Sciences)_. **17** (3): 348–375. [doi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Doi_(identifier)):[10.1016/0022-0000(78)90014-4](https://doi.org/10.1016%2F0022-0000%2878%2990014-4).
*   [Cardelli, Luca](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Luca_Cardelli "Luca Cardelli"); [Wegner, Peter](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Peter_Wegner "Peter Wegner") (December 1985). ["On Understanding Types, Data Abstraction, and Polymorphism"](http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf) (PDF). _[ACM Computing Surveys](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ACM_Computing_Surveys "ACM Computing Surveys")_. **17** (4): 471–523. [CiteSeerX](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/CiteSeerX_(identifier) "CiteSeerX (identifier)") [10.1.1.117.695](chrome-extension://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.117.695). [doi](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/6041.6042](https://doi.org/10.1145%2F6041.6042). [ISSN](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ISSN_(identifier) "ISSN (identifier)") [0360-0300](chrome-extension://www.worldcat.org/issn/0360-0300).
*   [Pierce, Benjamin C.](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Benjamin_C._Pierce "Benjamin C. Pierce") (2002). _Types and Programming Languages_. MIT Press. [ISBN](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-262-16209-8](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/wiki/Special:BookSources/978-0-262-16209-8 "Special:BookSources/978-0-262-16209-8").


[Source](https://en.wikipedia.org/wiki/Parametric_polymorphism#CITEREFCardelliWegner1985)