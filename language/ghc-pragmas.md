# Pragmas

<!-- TOC -->

- [Language options](#language-options)
- [LANGUAGE pragma](#language-pragma)
- [OPTIONS_GHC pragma](#options_ghc-pragma)
- [INCLUDE pragma](#include-pragma)
- [MINIMAL pragma](#minimal-pragma)
- [Other pragmas](#other-pragmas)

<!-- /TOC -->


https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas

Pragmas are instructions to the compiler placed in the source code. GHC supports several pragmas and they don't normally affect the meaning of the program, but they might affect the efficiency of the generated code.

Pragmas all take the form `{-# WORD ... #-}` where `⟨WORD⟩` indicates the type of pragma, optionally followed by specific info to that type of pragma.

- Case is ignored in `⟨WORD⟩`
- Any pragma with an unrecognised `⟨WORD⟩` is ignored
- The layout rule applies in pragmas, so the closing `#-}`
  should start in a column to the right of the opening `{-#`

Certain pragmas are file-header pragmas:
- file-header pragma must precede the `module` keyword
- there can be any number of file-header pragmas
- they can be preceded or followed by comments
- they are read once only, before pre-processing the file (e.g. with cpp)

The *file-header pragmas*:

```hs
{-# LANGUAGE    #-}
{-# OPTIONS_GHC #-}
{-# INCLUDE     #-}
```


https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html

Set LANGUAGE or OPTIONS_GHC pragmas:
- as flags on cmdline
- in module itself as a pragma on top
- in ghci.conf
- in project.cabal file
- probably in some enwar (?)

file://wsl%24/ubuntu1804/home/ivan/.ghc/ghci.conf
file://wsl%24/ubuntu1804/home/ivan/.haskeline




## Language options
The language extensions control what variation of the language are permitted.

Language options can be controlled in two ways:
1. cmdline flags: `-XTemplateHaskell` (on), `-XNoTemplateHaskell` (off)
2. Language options recognised by Cabal can also be enabled using the 
   LANGUAGE pragma, e.g. `{-# LANGUAGE TemplateHaskell #-}`


## LANGUAGE pragma

`{-# LANGUAGE ⟨ext⟩, ⟨ext⟩, ... #-}`

Enable or disable a set of language extensions. Every language extension can also be turned into a command-line flag by prefixing it with `-X`, e.g.`-XForeignFunctionInterface` (Similarly, all `-X` flags can be written as LANGUAGE pragmas).

List supported extensions: `ghc --supported-extensions`

Any extension from the `Extension` type defined in `Language.Haskell.Extension` may be used. GHC reports an error if any of the requested ext are not supported.


## OPTIONS_GHC pragma

{-# OPTIONS_GHC ⟨flags⟩ #-}

may also be set with flags and `OPTIONS_GHC` pragmas.

{-# OPTIONS_GHC -fno-warn-type-defaults      #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-orphans            #-}

The OPTIONS_GHC pragma is used to specify additional options that are given to the compiler when compiling this source file. See Command line options in source files for details.


## INCLUDE pragma

The INCLUDE used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.


## MINIMAL pragma
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#minimal-pragma

`{-# MINIMAL ⟨name⟩ | ⟨name⟩ , ... #-}`

Define the methods needed for a minimal complete instance of a class.
Where: class body

The `MINIMAL` pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults.

For example

```hs
class Eq a where
    (==) :: a -> a -> Bool
    x == y = not (x /= y)
    (/=) :: a -> a -> Bool
    x /= y = not (x == y)
    {-# MINIMAL (==) | (/=) #-}
```

> Without the `MINIMAL` pragma **no warning** would be generated for an instance that implements neither method.

A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.

If no MINIMAL pragma is given in the class declaration, it is just as if a pragma `{-# MINIMAL op_1, op_2, ..., op_n #-}` was given, where the `op_i` are the methods that lack a default method in the class declaration (c.f. `-Wmissing-methods`, Warnings and sanity-checking).

This warning can be turned off with the flag `-Wno-missing-methods`.



## Other pragmas

- WARNING
- DEPRECATED
- INLINE
- NOINLINE
- INLINABLE
- CONLIKE modifier
- LINE
- COLUMN
  Generated by preprocessors to convey source line numbers
- RULES
  The RULES pragma lets you specify rewrite rules.
- SPECIALISE 
  Ask that GHC specialize a polymorphic value to a particular type.
- SPECIALIZE INLINE
- SPECIALIZE instance
- UNPACK pragma
  Where: data ctor field. Instructs the compiler to unpack the contents of a ctor field into the ctor itself, removing a level of indirection.
- NOUNPACK pragma
- SOURCE pragma
- COMPLETE pragmas
  Specify the set of constructors or pattern synonyms which constitute a total match.
  
- OVERLAPPING
- OVERLAPPABLE
- OVERLAPS
- INCOHERENT

The pragmas OVERLAPPING, OVERLAPPABLE, OVERLAPS, INCOHERENT are used to specify the overlap behavior for individual instances, as described in Section Overlapping instances. The pragmas are written immediately after the instance keyword, like this: `instance {-# OVERLAPPING #-} C t where ...`





https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules
